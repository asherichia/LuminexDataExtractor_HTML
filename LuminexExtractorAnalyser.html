<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luminex data extractor and analysis tool</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Papa-Parse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Luminex data extractor and analysis tool</h1>
            <p>Web-based implementation for extracting data from Luminex CSV file exports, with SciPy 4PL curve fitting for standards, detection of hook effect/low quality standards, interpolation, and assigning samples as above/below cut offs for higher dilution testing</p>
        </div>

        <div class="section">
            <h2>üìÅ File Selection & Output Settings</h2>
            
            <!-- Main CSV File Input -->
            <div class="form-group">
                <label for="csvFile">
                    <strong>Luminex CSV Data File</strong>
                    <small style="display: block; font-weight: normal; color: #666; margin-top: 0.25rem;">
                        Select your exported Luminex CSV file containing sample data
                    </small>
                </label>
                <div class="file-input">
                    <input type="file" id="csvFile" accept=".csv" />
                    <p>üìÑ Click here to select your Luminex CSV file</p>
                </div>
            </div>
            
            <!-- Output Configuration -->
            <div class="grid">
                <div class="form-group">
                    <label for="outputFolder">
                        <strong>Output Folder Name</strong>
                        <small style="display: block; font-weight: normal; color: #666; margin-top: 0.25rem;">
                            Name for the results folder
                        </small>
                    </label>
                    <input type="text" id="outputFolder" value="LuminexResults" placeholder="e.g. LuminexResults_2024-01-15" />
                </div>
                
                <div class="form-group">
                    <label for="outputDirectory">
                        <strong>Output Location</strong>
                        <small style="display: block; font-weight: normal; color: #666; margin-top: 0.25rem;">
                            Choose where to save results
                        </small>
                    </label>
                    <button class="btn" id="selectOutputDir">üìÇ Choose Directory</button>
                    <p id="selectedDirPath" style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                        üí° <em>No custom directory selected - files will download to your default Downloads folder</em>
                    </p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üîÑ File Preprocessing</h2>
            <p style="color: #666; margin-bottom: 1.5rem;">Configure how the Luminex CSV file should be processed and validated.</p>
            
            <div class="grid">
                <div class="form-group">
                    <label for="plateFormat">
                        <strong>Plate Format</strong>
                        <small style="display: block; font-weight: normal; color: #666; margin-top: 0.25rem;">
                            Select the format of your Luminex plate
                        </small>
                    </label>
                    <select id="plateFormat">
                        <option value="96-well">96-well plate</option>
                        <option value="384-well">384-well plate</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="numWells">
                        <strong>Number of Wells</strong>
                        <small style="display: block; font-weight: normal; color: #666; margin-top: 0.25rem;">
                            Total wells to process (auto-calculated for full plates)
                        </small>
                    </label>
                    <input type="number" id="numWells" value="96" min="1" max="384" disabled />
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group" style="margin-top: 1.5rem;">
                        <input type="checkbox" id="fullPlate" checked />
                        <label for="fullPlate">üß™ <strong>Process Full Plate</strong></label>
                        <small style="display: block; color: #666; margin-top: 0.25rem; margin-left: 1.5rem;">
                            Process all wells in the plate (uncheck to specify custom well count)
                        </small>
                    </div>
                </div>
            </div>
            
            <button class="btn" id="preprocessBtn" disabled style="margin-top: 1rem;">
                üöÄ Start Preprocessing
            </button>
        </div>

        <div class="section">
            <h2>‚öôÔ∏è Analysis Configuration</h2>
            
            <!-- Optional Configuration Files -->
            <div style="background: #f8f9fa; border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                <h3 style="margin-bottom: 1rem; color: #495057; font-size: 1.1rem;">üìä Optional Configuration Files</h3>
                <div class="grid">
                    <div class="form-group">
                        <label for="standardsFile">
                            <strong>Standards Concentration File</strong>
                            <small style="display: block; font-weight: normal; color: #666; margin-top: 0.25rem;">
                                CSV with standard sample concentrations (optional - will auto-detect if not provided)
                            </small>
                        </label>
                        <div class="file-input">
                            <input type="file" id="standardsFile" accept=".csv" />
                            <p id="standardsFileStatus">üìã Click to select standards file (optional)</p>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="cutoffFile">
                            <strong>Sample Cutoff Values</strong>
                            <small style="display: block; font-weight: normal; color: #666; margin-top: 0.25rem;">
                                CSV with cutoff concentrations for sample classification (optional)
                            </small>
                        </label>
                        <div class="file-input">
                            <input type="file" id="cutoffFile" accept=".csv" />
                            <p id="cutoffFileStatus">‚úÇÔ∏è Click to select cutoff file (optional)</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Analysis Parameters -->
            <div style="background: #fff; border: 1px solid #e9ecef; border-radius: 8px; padding: 1rem;">
                <h3 style="margin-bottom: 1rem; color: #495057; font-size: 1.1rem;">üîß Analysis Parameters</h3>
                <div class="grid">
                
                    <div class="form-group">
                        <label for="bgSample">
                            <strong>Background Sample Name</strong>
                            <small style="display: block; font-weight: normal; color: #666; margin-top: 0.25rem;">
                                Sample name used for background subtraction
                            </small>
                        </label>
                        <input type="text" id="bgSample" value="Background0" placeholder="e.g. Background0, Blank" />
                    </div>
                    
                    <div class="form-group">
                        <label for="dilutionFactor">
                            <strong>Dilution Multiplier</strong>
                            <small style="display: block; font-weight: normal; color: #666; margin-top: 0.25rem;">
                                Factor to adjust concentrations (e.g. 2 for 1:2 dilution)
                            </small>
                        </label>
                        <input type="number" id="dilutionFactor" value="1" min="0.01" step="0.01" placeholder="1.0" />
                    </div>
                    
                    <div class="form-group">
                        <label style="font-weight: 600; margin-bottom: 0.75rem; display: block;">Analysis Options</label>
                        <div class="checkbox-group" style="margin-bottom: 0.5rem;">
                            <input type="checkbox" id="detectHook" checked />
                            <label for="detectHook">üîç Detect Hook Effect</label>
                            <small style="display: block; color: #666; margin-top: 0.25rem; margin-left: 1.5rem;">
                                Identify high-dose inhibition in immunoassays
                            </small>
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="filterLowStd" />
                            <label for="filterLowStd">üßπ Filter Low Standards</label>
                            <small style="display: block; color: #666; margin-top: 0.25rem; margin-left: 1.5rem;">
                                Remove standards too close to background or breaking dose-response pattern
                            </small>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="validationStatus" style="display: none; margin-top: 1rem; padding: 1rem; border-radius: 5px;">
                <h4>Analysis Validation:</h4>
                <div id="validationDetails"></div>
            </div>
            
            <button class="btn" id="validateOptionsBtn" style="margin-top: 1rem;" disabled>Validate Analysis Setup</button>
        </div>

        <div class="section">
            <h2>4. Analyte Selection</h2>
            <div class="form-group">
                <label for="analyteSelect">Select Analyte:</label>
                <select id="analyteSelect" disabled>
                    <option value="">Please preprocess file first</option>
                </select>
            </div>
            
            <button class="btn" id="runAnalysisBtn" disabled>Run Analysis</button>
        </div>

        <div class="section" id="progressSection" style="display: none;">
            <h2>Analysis Progress</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="statusMessage" class="status info">Ready to begin analysis...</div>
        </div>

        <div class="section" id="resultsSection" style="display: none;">
            <h2>5. Results</h2>
            
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="graphs">Graphs</button>
                    <button class="tab-button" data-tab="data">Data Tables</button>
                    <button class="tab-button" data-tab="iqc">IQC Analysis</button>
                    <button class="tab-button" data-tab="summary">Summary</button>
                </div>
                
                <div class="tab-content active" id="graphs">
                    <div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 5px; border: 1px solid #e9ecef;">
                        <label style="font-weight: 600; margin-bottom: 0.5rem; display: block;">Global Chart Axis Controls:</label>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" id="globalXAxisToggle" style="font-size: 12px; padding: 5px 10px;" disabled>X-Axis: Log</button>
                            <button class="btn" id="globalYAxisToggle" style="font-size: 12px; padding: 5px 10px;" disabled>Y-Axis: Linear</button>
                        </div>
                        <small style="color: #666; font-size: 0.9em; margin-top: 5px; display: block;">Use these controls to toggle all chart axes between linear and logarithmic scales.</small>
                    </div>
                    <div id="graphsContainer"></div>
                </div>
                
                <div class="tab-content" id="data">
                    <div id="dataTablesContainer"></div>
                </div>
                
                <div class="tab-content" id="iqc">
                    <div id="iqcContainer">
                        <div id="iqcSummary" style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 5px;">
                            <h3>Internal Quality Control (IQC) Analysis</h3>
                            <p>This section displays data and analysis for quality control samples (IQC1, IQC2, IQC3 or Control1, Control2, Control3).</p>
                        </div>
                        <div id="iqcChartsContainer"></div>
                        <div id="iqcTablesContainer"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="summary">
                    <div id="summaryContainer"></div>
                </div>
            </div>
        </div>

        <div class="section download-section" id="downloadSection">
            <h2>6. Download Results</h2>
            <div id="downloadList"></div>
            <button class="btn" id="downloadAllBtn">Download All Files as ZIP</button>
        </div>
    </div>

    <script>
        // Global variables
        let processedData = null;
        let analytes = [];
        let analysisResults = {};
        let generatedFiles = {};
        let outputDirectoryHandle = null;
        let currentOutputFolder = null;
        let cleanDataFile = null;
        let pyodideInstance = null; // For Pyodide
        
        // Global chart axis state
        let globalXAxisLog = true;  // Default X-axis to log
        let globalYAxisLog = false; // Default Y-axis to linear
        let allCharts = []; // Array to store all chart instances

        // Function to export chart as image data URL
        async function exportChartAsImage(chartInfo) {
            try {
                const canvas = chartInfo.canvas;
                console.log(`Exporting chart: ${chartInfo.filename}`, {
                    canvas: canvas,
                    width: canvas.width,
                    height: canvas.height,
                    type: chartInfo.type,
                    chartExists: !!chartInfo.chart,
                    canvasInDOM: document.body.contains(canvas),
                    canvasParent: canvas.parentElement ? canvas.parentElement.className : 'no parent'
                });
                
                // Check if canvas has content
                const context = canvas.getContext('2d');
                const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                const hasContent = imageData.data.some(pixel => pixel !== 0);
                console.log(`Canvas has content: ${hasContent}`);
                
                // If no content, try to force a redraw
                if (!hasContent && chartInfo.chart) {
                    console.log('Canvas empty, forcing chart redraw...');
                    chartInfo.chart.update('none');
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Convert canvas to blob directly (better for JSZip)
                return new Promise((resolve, reject) => {
                    canvas.toBlob((blob) => {
                        if (blob) {
                            console.log(`Export successful: ${blob.size} bytes for ${chartInfo.filename}`);
                            resolve(blob);
                        } else {
                            console.error(`Failed to create blob for ${chartInfo.filename}`);
                            reject(new Error('Failed to create blob'));
                        }
                    }, 'image/png', 1.0);
                });
            } catch (error) {
                console.error('Error exporting chart:', chartInfo.filename, error);
                return null;
            }
        }

        // Function to add all charts to generated files for export
        async function addChartsToExport() {
            const outputFolder = document.getElementById('outputFolder').value || "LuminexResults";
            
            console.log(`\n=== STARTING CHART EXPORT ===`);
            console.log(`Found ${allCharts.length} total charts, ${allCharts.filter(c => c.type === 'standard_curve' || c.type === 'efficiency').length} standard curves and efficiency charts to export`);
            
            // Charts will export from their current tabs - no auto switching visible to user
            // Wait for charts to be ready
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Filter charts to export standard curves and efficiency charts (not IQC charts)
            const chartsToExport = allCharts.filter(chart => chart.type === 'standard_curve' || chart.type === 'efficiency');
            console.log(`Filtered to ${chartsToExport.length} charts for export (standard curves and efficiency charts)`);
            
            // Process charts sequentially to ensure proper timing
            for (let i = 0; i < chartsToExport.length; i++) {
                const chartInfo = chartsToExport[i];
                console.log(`Processing chart ${i + 1}/${chartsToExport.length}: ${chartInfo.filename} (${chartInfo.type})`);
                
                if (!chartInfo || !chartInfo.canvas || !chartInfo.filename) {
                    console.error(`‚ùå Invalid chart info for ${chartInfo?.filename || 'unknown'}`);
                    continue;
                }
                
                try {
                    // Charts export without tab switching - less disruptive to user
                    
                    // Check canvas status
                    const canvasInDOM = document.contains(chartInfo.canvas);
                    if (!canvasInDOM) {
                        console.error(`‚ùå Canvas not in DOM for ${chartInfo.filename}`);
                        continue;
                    }
                    
                    // If canvas has lost dimensions, force a complete refresh
                    if (chartInfo.canvas.width === 0 || chartInfo.canvas.height === 0) {
                        console.warn(`Canvas lost dimensions for ${chartInfo.filename}, forcing complete refresh...`);
                        
                        // Destroy and recreate the chart
                        if (chartInfo.chart && typeof chartInfo.chart.destroy === 'function') {
                            chartInfo.chart.destroy();
                        }
                        
                        // Set canvas dimensions explicitly
                        chartInfo.canvas.width = 1080;
                        chartInfo.canvas.height = 400;
                        chartInfo.canvas.style.width = '1080px';
                        chartInfo.canvas.style.height = '400px';
                        
                        // Recreate Chart.js instance with same configuration
                        const ctx = chartInfo.canvas.getContext('2d');
                        console.log(`Recreating chart for export: ${chartInfo.filename}`);
                        
                        // We'll need to skip this chart for now since we don't have the original data
                        console.warn(`‚ö†Ô∏è Skipping chart with lost dimensions: ${chartInfo.filename}`);
                        continue;
                    }
                    
                    // Force chart to update/render before export with multiple attempts
                    if (chartInfo.chart && typeof chartInfo.chart.update === 'function') {
                        // Multiple resize attempts
                        for (let attempt = 0; attempt < 3; attempt++) {
                            chartInfo.chart.update('none');
                            chartInfo.chart.resize();
                            if (typeof chartInfo.chart.render === 'function') {
                                chartInfo.chart.render();
                            }
                            await new Promise(resolve => setTimeout(resolve, 300));
                            
                            // Check if dimensions are now correct
                            if (chartInfo.canvas.width > 0 && chartInfo.canvas.height > 0) {
                                console.log(`Chart resize successful on attempt ${attempt + 1}: ${chartInfo.canvas.width}x${chartInfo.canvas.height}`);
                                break;
                            }
                        }
                    }
                    
                    // Final check and manual dimension setting if still 0x0
                    if (chartInfo.canvas.width === 0 || chartInfo.canvas.height === 0) {
                        console.warn(`Chart still has 0 dimensions, forcing manual resize...`);
                        chartInfo.canvas.width = 1080;
                        chartInfo.canvas.height = 400;
                        if (chartInfo.chart && typeof chartInfo.chart.resize === 'function') {
                            chartInfo.chart.resize();
                            if (typeof chartInfo.chart.render === 'function') {
                                chartInfo.chart.render();
                            }
                        }
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    
                    const imageBytes = await exportChartAsImage(chartInfo);
                    
                    if (imageBytes && (imageBytes.size > 0 || imageBytes.length > 0)) {
                        const filename = `${outputFolder}_${chartInfo.filename}`;
                        generatedFiles[filename] = imageBytes;
                        console.log(`‚úÖ Exported: ${filename} (${imageBytes.size || imageBytes.length} bytes)`);
                    } else {
                        console.warn(`‚ö†Ô∏è Failed to export: ${chartInfo.filename}`);
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Error exporting ${chartInfo.filename}: ${error.message}`);
                }
            }
            
            console.log(`=== CHART EXPORT COMPLETE ===`);
            const chartFiles = Object.keys(generatedFiles).filter(f => f.includes('.png'));
            console.log(`Successfully exported ${chartFiles.length} PNG files`);
        }

        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            initializeEventListeners();
            console.log('Event listeners initialized');
        });

        function initializeEventListeners() {
            // Check all required elements exist
            const requiredElements = ['csvFile', 'preprocessBtn', 'outputFolder', 'plateFormat', 'fullPlate', 'numWells'];
            requiredElements.forEach(id => {
                const element = document.getElementById(id);
                console.log(`Element ${id}:`, element ? 'Found' : 'NOT FOUND');
            });
            
            // File inputs
            const csvFile = document.getElementById('csvFile');
            if (csvFile) {
                csvFile.addEventListener('change', handleFileSelection);
                console.log('CSV file listener added');
                
                // Add additional reliability by resetting on click
                csvFile.addEventListener('click', function() {
                    this.value = ''; // Reset to ensure change event fires even for same file
                });
            }
            
            const standardsFile = document.getElementById('standardsFile');
            if (standardsFile) {
                standardsFile.addEventListener('change', handleStandardsFile);
                console.log('Standards file listener added');
                
                // Add additional reliability by resetting on click
                standardsFile.addEventListener('click', function() {
                    this.value = ''; // Reset to ensure change event fires even for same file
                });
            } else {
                console.error('Standards file input not found');
            }
            
            const cutoffFile = document.getElementById('cutoffFile');
            if (cutoffFile) {
                cutoffFile.addEventListener('change', handleCutoffFile);
                console.log('Cutoff file listener added');
                
                // Add additional reliability by resetting on click
                cutoffFile.addEventListener('click', function() {
                    this.value = ''; // Reset to ensure change event fires even for same file
                });
            } else {
                console.error('Cutoff file input not found');
            }
            
            // Plate format changes
            const plateFormat = document.getElementById('plateFormat');
            if (plateFormat) {
                plateFormat.addEventListener('change', updateWellCount);
            }
            
            const fullPlate = document.getElementById('fullPlate');
            if (fullPlate) {
                fullPlate.addEventListener('change', toggleWellCount);
            }
            
            // Buttons
            const preprocessBtn = document.getElementById('preprocessBtn');
            if (preprocessBtn) {
                preprocessBtn.addEventListener('click', preprocessFile);
                console.log('Preprocess button listener added');
            } else {
                console.error('preprocessBtn not found during initialization!');
            }
            
            const runAnalysisBtn = document.getElementById('runAnalysisBtn');
            if (runAnalysisBtn) {
                runAnalysisBtn.addEventListener('click', runAnalysis);
            }
            
            const downloadAllBtn = document.getElementById('downloadAllBtn');
            if (downloadAllBtn) {
                downloadAllBtn.addEventListener('click', downloadAllFiles);
            }
            
            const selectOutputDir = document.getElementById('selectOutputDir');
            if (selectOutputDir) {
                selectOutputDir.addEventListener('click', selectOutputDirectory);
            }
            
            const validateOptionsBtn = document.getElementById('validateOptionsBtn');
            if (validateOptionsBtn) {
                validateOptionsBtn.addEventListener('click', validateAnalysisSetup);
            }
            
            // Tab navigation
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', function() {
                    switchTab(this.dataset.tab);
                });
            });
            
            // Global axis controls
            const globalXAxisToggle = document.getElementById('globalXAxisToggle');
            if (globalXAxisToggle) {
                globalXAxisToggle.addEventListener('click', toggleGlobalXAxis);
            }
            
            const globalYAxisToggle = document.getElementById('globalYAxisToggle');
            if (globalYAxisToggle) {
                globalYAxisToggle.addEventListener('click', toggleGlobalYAxis);
            }
        }
        
        function toggleGlobalXAxis() {
            globalXAxisLog = !globalXAxisLog;
            const btn = document.getElementById('globalXAxisToggle');
            btn.textContent = globalXAxisLog ? 'X-Axis: Log' : 'X-Axis: Linear';
            
            // Update all charts
            allCharts.forEach(chartObj => {
                if (chartObj.chart && chartObj.chart.options && chartObj.chart.options.scales && chartObj.chart.options.scales.x) {
                    chartObj.chart.options.scales.x.type = globalXAxisLog ? 'logarithmic' : 'linear';
                    chartObj.chart.options.scales.x.title.text = globalXAxisLog ? 'Concentration (Log Scale)' : 'Concentration (Linear Scale)';
                    chartObj.chart.update('none');
                }
            });
        }
        
        function toggleGlobalYAxis() {
            globalYAxisLog = !globalYAxisLog;
            const btn = document.getElementById('globalYAxisToggle');
            btn.textContent = globalYAxisLog ? 'Y-Axis: Log' : 'Y-Axis: Linear';
            
            // Update all charts (skip efficiency charts - they should stay linear)
            allCharts.forEach(chartObj => {
                if (chartObj.chart && chartObj.chart.options && chartObj.chart.options.scales && chartObj.chart.options.scales.y && chartObj.type !== 'efficiency') {
                    chartObj.chart.options.scales.y.type = globalYAxisLog ? 'logarithmic' : 'linear';
                    chartObj.chart.options.scales.y.title.text = globalYAxisLog ? 'Corrected MFI (Log Scale)' : 'Corrected MFI (Linear Scale)';
                    chartObj.chart.update('none');
                }
            });
        }
        
        function formatNumber(value) {
            if (value === null || value === undefined || !isFinite(value)) {
                return 'N/A';
            }
            
            const absValue = Math.abs(value);
            
            // Use scientific notation for numbers >= 1,000,000 (6+ digits)
            if (absValue >= 1000000) {
                return value.toExponential(4);
            }
            
            // For all other numbers, use 4 decimal places
            return value.toFixed(4);
        }
        
        function formatMfiConc(value) {
            // Special formatting for MFI and concentration values - always 4 decimal places
            if (value === null || value === undefined || !isFinite(value)) {
                return 'N/A';
            }
            
            const absValue = Math.abs(value);
            
            // Use scientific notation for numbers >= 1,000,000 (6+ digits)
            if (absValue >= 1000000) {
                return value.toExponential(4);
            }
            
            // For all other numbers, use 4 decimal places
            return value.toFixed(4);
        }

        async function loadPyodideAndPackages() {
            const runAnalysisBtn = document.getElementById('runAnalysisBtn');
            const originalRunBtnText = runAnalysisBtn ? runAnalysisBtn.textContent : "Run Analysis";

            if (!pyodideInstance) {
                updateStatus('Loading Pyodide runtime (this may take a moment)...', 'info');
                if(runAnalysisBtn) {
                    runAnalysisBtn.disabled = true;
                    runAnalysisBtn.textContent = "Loading SciPy...";
                }

                try {
                    pyodideInstance = await loadPyodide({
                        indexURL: "https://cdn.jsdelivr.net/pyodide/v0.25.1/full/"
                    });
                    updateStatus('Pyodide loaded. Loading packages (numpy, scipy)...', 'info');
                    await pyodideInstance.loadPackage(['numpy', 'scipy']);
                    updateStatus('Python (SciPy, Numpy) loaded successfully.', 'success');
                } catch (error) {
                    console.error("Pyodide or package loading failed:", error);
                    updateStatus(`Error loading Pyodide/SciPy: ${error}. Analysis may not be accurate.`, 'error');
                    pyodideInstance = null; // Prevent further attempts if failed
                    if(runAnalysisBtn) runAnalysisBtn.textContent = originalRunBtnText; // Reset button text
                    throw error; // Propagate error
                } finally {
                     if(runAnalysisBtn && processedData && document.getElementById('analyteSelect').value) {
                        runAnalysisBtn.disabled = false;
                     }
                     if(runAnalysisBtn) runAnalysisBtn.textContent = originalRunBtnText;
                }
            }
            return pyodideInstance;
        }


        function handleFileSelection(event) {
            const file = event.target.files[0];
            console.log('File selection triggered:', file);
            if (file) {
                updateStatus('File selected: ' + file.name, 'info');
                const preprocessBtn = document.getElementById('preprocessBtn');
                console.log('Preprocess button found:', preprocessBtn);
                if (preprocessBtn) {
                    preprocessBtn.disabled = false;
                    console.log('Preprocess button enabled');
                } else {
                    console.error('Preprocess button not found!');
                }
                
                // Generate timestamp for output folder
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const outputFolder = document.getElementById('outputFolder');
                if (outputFolder) {
                    outputFolder.value = `LuminexResults_${timestamp}`;
                }
            } else {
                console.log('No file selected');
            }
        }

        function handleStandardsFile(event) {
            try {
                const file = event.target.files[0];
                if (file) {
                    // Validate file type
                    if (!file.name.toLowerCase().endsWith('.csv')) {
                        updateStatus('Error: Standards file must be a CSV file', 'error');
                        document.getElementById('standardsFileStatus').textContent = 'Error: Must be a CSV file';
                        document.getElementById('standardsFileStatus').style.color = '#dc3545';
                        return;
                    }
                    
                    updateStatus('Standards file selected: ' + file.name, 'info');
                    document.getElementById('standardsFileStatus').textContent = 'Selected: ' + file.name;
                    document.getElementById('standardsFileStatus').style.color = '#28a745';
                    console.log('Standards file selected:', file.name, 'Size:', file.size, 'bytes');
                } else {
                    document.getElementById('standardsFileStatus').textContent = 'Click to select standards file';
                    document.getElementById('standardsFileStatus').style.color = '';
                }
            } catch (error) {
                console.error('Error handling standards file:', error);
                updateStatus('Error selecting standards file: ' + error.message, 'error');
                document.getElementById('standardsFileStatus').textContent = 'Error selecting file';
                document.getElementById('standardsFileStatus').style.color = '#dc3545';
            }
        }

        function handleCutoffFile(event) {
            try {
                const file = event.target.files[0];
                if (file) {
                    // Validate file type
                    if (!file.name.toLowerCase().endsWith('.csv')) {
                        updateStatus('Error: Cutoff file must be a CSV file', 'error');
                        document.getElementById('cutoffFileStatus').textContent = 'Error: Must be a CSV file';
                        document.getElementById('cutoffFileStatus').style.color = '#dc3545';
                        return;
                    }
                    
                    updateStatus('Cutoff file selected: ' + file.name, 'info');
                    document.getElementById('cutoffFileStatus').textContent = 'Selected: ' + file.name;
                    document.getElementById('cutoffFileStatus').style.color = '#28a745';
                    console.log('Cutoff file selected:', file.name, 'Size:', file.size, 'bytes');
                } else {
                    document.getElementById('cutoffFileStatus').textContent = 'Click to select cutoff file';
                    document.getElementById('cutoffFileStatus').style.color = '';
                }
            } catch (error) {
                console.error('Error handling cutoff file:', error);
                updateStatus('Error selecting cutoff file: ' + error.message, 'error');
                document.getElementById('cutoffFileStatus').textContent = 'Error selecting file';
                document.getElementById('cutoffFileStatus').style.color = '#dc3545';
            }
        }

        function updateWellCount() {
            const plateFormat = document.getElementById('plateFormat').value;
            const wellInput = document.getElementById('numWells');
            
            if (plateFormat === '96-well') {
                wellInput.value = '96';
            } else {
                wellInput.value = '384';
            }
        }

        function toggleWellCount() {
            const fullPlate = document.getElementById('fullPlate').checked;
            const wellInput = document.getElementById('numWells');
            
            wellInput.disabled = fullPlate;
            if (fullPlate) {
                updateWellCount();
            }
        }

        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            
            // Show progress section
            document.getElementById('progressSection').style.display = 'block';
        }

        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        async function preprocessFile() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];
            
            if (!file) {
                updateStatus('Please select a CSV file first', 'error');
                return;
            }

            console.log('Starting file preprocessing...');
            updateStatus('Reading CSV file...', 'info');
            updateProgress(10);

            // Use the fallback CSV parsing method directly (more reliable)
            const reader = new FileReader();
            
            reader.onload = async function(e) {
                try {
                    console.log('FileReader completed, processing text...');
                    const text = e.target.result;
                    console.log('File text length:', text.length);
                    
                    // Proper CSV parsing to handle quoted fields like "1(1,A1)"
                    const lines = text.split(/\r?\n/);
                    console.log('Total lines found:', lines.length);
                    
                    const csvData = lines.map(line => {
                        // Parse CSV line respecting quotes
                        const result = [];
                        let current = '';
                        let inQuotes = false;
                        
                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            
                            if (char === '"') {
                                inQuotes = !inQuotes;
                            } else if (char === ',' && !inQuotes) {
                                result.push(current.trim());
                                current = '';
                            } else {
                                current += char;
                            }
                        }
                        
                        // Add the last field
                        result.push(current.trim());
                        
                        return result;
                    });
                    
                    console.log('Parsed into', csvData.length, 'rows');
                    updateProgress(30);
                    
                    // Continue with processing
                    updateStatus('Processing CSV data...', 'info');
                    processedData = preprocessCSVData(csvData);
                    updateProgress(40);
                    
                    // Create clean data file and leftover file
                    updateStatus('Creating output files...', 'info');
                    const outputResult = await createOutputFiles(processedData, csvData);
                    cleanDataFile = outputResult.cleanData;
                    updateProgress(60);
                    
                    updateStatus('Extracting analytes...', 'info');
                    analytes = extractAnalytes(processedData);
                    updateProgress(80);
                    
                    updateAnalyteDropdown();
                    
                    updateProgress(100);
                    updateStatus(`File preprocessed successfully. Found ${analytes.length} analytes. Created clean data file (${processedData.data.length} samples).`, 'success');
                    
                    // Check for standards in the data (case-sensitive check)
                    const standardSamples = processedData.data.filter(row => {
                        const sampleName = String(row.Sample || row.sample || '');
                        return sampleName.includes('Standard') || sampleName.includes('standard') || 
                               sampleName.includes('Std') || sampleName.includes('std') ||
                               sampleName.includes('Cal') || sampleName.includes('cal');
                    });
                    
                    // Show some preprocessing info
                    const infoDiv = document.createElement('div');
                    infoDiv.style.marginTop = '1rem';
                    infoDiv.style.padding = '1rem';
                    infoDiv.style.backgroundColor = '#f8f9fa';
                    infoDiv.style.borderRadius = '5px';
                    
                    let standardsInfo = '';
                    if (standardSamples.length > 0) {
                        const standardNames = standardSamples.map(row => row.Sample || row.sample).slice(0, 5);
                        standardsInfo = `<br>‚Ä¢ Standard samples detected: ${standardNames.join(', ')}${standardSamples.length > 5 ? ` and ${standardSamples.length - 5} more` : ''}<br>‚Ä¢ <strong style="color: #d63384;">IMPORTANT:</strong> Upload a standards CSV file with concentration values for analysis`;
                    } else {
                        standardsInfo = '<br>‚Ä¢ No standard samples detected in data';
                    }
                    
                    infoDiv.innerHTML = `
                        <strong>Preprocessing Results:</strong><br>
                        ‚Ä¢ Total samples: ${processedData.data.length}<br>
                        ‚Ä¢ Analytes detected: ${analytes.join(', ')}<br>
                        ‚Ä¢ Clean data file and leftover data file created${standardsInfo}<br>
                        ‚Ä¢ Ready for analysis
                    `;
                    
                    const progressSection = document.getElementById('progressSection');
                    if (!progressSection.querySelector('.preprocessing-info')) {
                        infoDiv.className = 'preprocessing-info';
                        progressSection.appendChild(infoDiv);
                    }
                    
                    // Show download section with preprocessing files
                    showPreprocessingDownloads();
                    
                    // Enable validation and analysis buttons
                    document.getElementById('validateOptionsBtn').disabled = false;
                    document.getElementById('runAnalysisBtn').disabled = false;
                    console.log('Preprocessing completed successfully');
                    
                } catch (error) {
                    console.error('Preprocessing error:', error);
                    updateStatus('Error preprocessing file: ' + error.message, 'error');
                }
            };
            
            reader.onerror = function(error) {
                console.error('FileReader error:', error);
                updateStatus('Error reading file: ' + error.message, 'error');
            };
            
            reader.readAsText(file);
        }


        async function createOutputFiles(processedData, rawData) {
            console.log('Creating output files...');
            const outputFolder = document.getElementById('outputFolder').value;
            
            // Create clean data CSV (just the processed data)
            const cleanCSV = processedDataToCSV(processedData);
            
            // Create leftover data file (everything before and after the main data)
            const leftoverCSV = createLeftoverDataCSV(rawData, processedData);
            
            // Store files for later download
            if (!generatedFiles) generatedFiles = {};
            generatedFiles[`${outputFolder}_clean_data.csv`] = cleanCSV;
            generatedFiles[`${outputFolder}_leftover_data.csv`] = leftoverCSV;
            
            console.log('Output files created successfully');
            
            return {
                cleanData: cleanCSV,
                leftoverData: leftoverCSV
            };
        }
        
        function processedDataToCSV(processedData) {
            if (!processedData || !processedData.headers || !processedData.data) {
                throw new Error('Invalid processed data structure');
            }
            
            let csv = processedData.headers.join(',') + '\n';
            
            processedData.data.forEach(row => {
                const csvRow = processedData.headers.map(header => {
                    const value = row[header] || '';
                    // Escape commas and quotes in CSV values
                    if (String(value).includes(',') || String(value).includes('"')) {
                        return '"' + String(value).replace(/"/g, '""') + '"';
                    }
                    return value;
                });
                csv += csvRow.join(',') + '\n';
            });
            
            return csv;
        }
        
        function createLeftoverDataCSV(rawData, processedData) {
            // Find where the processed data starts and ends in the raw data
            let processedStart = -1;
            let processedEnd = -1;
            
            // Look for the header row containing "Sample"
            for (let i = 0; i < rawData.length; i++) {
                if (rawData[i] && rawData[i].length > 0) {
                    for (let j = 0; j < rawData[i].length; j++) {
                        const cell = String(rawData[i][j]).toLowerCase().trim();
                        if (cell === 'sample') {
                            processedStart = i;
                            // Estimate end based on processed data length
                            processedEnd = i + processedData.data.length + 1; // +1 for header
                            break;
                        }
                    }
                    if (processedStart !== -1) break;
                }
            }
            
            let leftoverCSV = '';
            
            // Add header comment
            leftoverCSV += '# Leftover data from Luminex file preprocessing\n';
            leftoverCSV += '# This file contains data that was not included in the main analysis\n\n';
            
            // Add data before processed section
            if (processedStart > 0) {
                leftoverCSV += '# Data before main analysis section:\n';
                for (let i = 0; i < processedStart; i++) {
                    if (rawData[i] && rawData[i].length > 0) {
                        leftoverCSV += rawData[i].join(',') + '\n';
                    }
                }
                leftoverCSV += '\n';
            }
            
            // Add data after processed section
            if (processedEnd < rawData.length) {
                leftoverCSV += '# Data after main analysis section:\n';
                for (let i = processedEnd; i < rawData.length; i++) {
                    if (rawData[i] && rawData[i].length > 0) {
                        leftoverCSV += rawData[i].join(',') + '\n';
                    }
                }
            }
            
            return leftoverCSV;
        }

        function preprocessCSVData(rawData) {
            console.log('Starting CSV preprocessing...');
            console.log('Total rows in raw data:', rawData.length);
            
            if (!rawData || rawData.length === 0) {
                throw new Error('No data found in CSV file');
            }
            
            const plateFormat = document.getElementById('plateFormat').value;
            const isFullPlate = document.getElementById('fullPlate').checked;
            const numWells = parseInt(document.getElementById('numWells').value);
            
            // Look for the data marker "DataType:","Median" or find the Sample column
            let dataStartRow = -1;
            let headerRow = -1;
            
            // Search for the header row containing "Sample" - look in all cells, not just first
            for (let i = 0; i < rawData.length; i++) {
                if (rawData[i] && rawData[i].length > 0) {
                    // Check all cells in the row for "Sample"
                    for (let j = 0; j < rawData[i].length; j++) {
                        const cell = String(rawData[i][j]).toLowerCase().trim();
                        if (cell === 'sample') {
                            headerRow = i;
                            dataStartRow = i + 1;
                            break;
                        }
                    }
                    if (headerRow !== -1) break;
                }
            }
            
            // If not found, try the original approach (row 51)
            if (headerRow === -1) {
                console.log('Using fallback approach - row 51');
                headerRow = 51; // Typically header is on row 52 (index 51)
                dataStartRow = 52; // Data starts on row 53 (index 52)
                
                // Check if this row exists and has data
                if (rawData.length <= headerRow || !rawData[headerRow]) {
                    // Try another common header row if default fails (e.g. for some Bio-Plex outputs)
                     headerRow = 8; // A common alternative
                     dataStartRow = 9;
                     if (rawData.length <= headerRow || !rawData[headerRow] || !rawData[headerRow].some(h => String(h).toLowerCase().trim() === 'sample')) {
                        throw new Error('Could not find header row ("Sample"). CSV format may be different than expected. Standard headers usually at row 9 or 52.');
                     }
                }
            }
            
            console.log('Header row found at:', headerRow);
            console.log('Data starts at row:', dataStartRow);
            
            // Extract headers
            const headers = rawData[headerRow];
            if (!headers || headers.length === 0) {
                throw new Error('No headers found at row ' + headerRow);
            }
            
            console.log('Headers found:', headers.slice(0, 10), '...');
            
            // Calculate data end row more intelligently
            let dataEndRow;
            
            // First, try to find where the data actually ends by looking for empty rows
            let actualDataRows = 0;
            for (let i = dataStartRow; i < rawData.length; i++) {
                if (rawData[i] && rawData[i].length > 0) {
                    // Check if this row has meaningful data (not all empty)
                    const hasData = rawData[i].some(cell => cell && String(cell).trim() !== '');
                    if (hasData) {
                        actualDataRows++;
                    } else {
                        // Found empty row, likely end of data
                        break;
                    }
                } else {
                    // Found empty row
                    break;
                }
            }
            
            console.log('Found', actualDataRows, 'actual data rows');
            
            // Use the smaller of: expected wells or actual data found
            if (isFullPlate) {
                const expectedWells = plateFormat === '96-well' ? 96 : 384;
                dataEndRow = dataStartRow + Math.min(actualDataRows, expectedWells) - 1;
            } else {
                dataEndRow = dataStartRow + Math.min(actualDataRows, numWells) - 1;
            }
            
            // Ensure we don't exceed available data
            dataEndRow = Math.min(dataEndRow, rawData.length - 1);
            
            console.log('Data end row calculated as:', dataEndRow);
            
            // Extract data rows
            const dataRows = [];
            for (let i = dataStartRow; i <= dataEndRow; i++) {
                if (i < rawData.length && rawData[i]) {
                    dataRows.push(rawData[i]);
                }
            }
            
            console.log('Extracted', dataRows.length, 'data rows');
            
            if (dataRows.length === 0) {
                throw new Error('No data rows found. Check plate format settings or file integrity.');
            }
            
            // Convert to objects with proper headers
            const processedRows = dataRows.map((row, index) => {
                const obj = {};
                headers.forEach((header, headerIndex) => {
                    if (header && header.trim()) { // Ensure header is not empty or just whitespace
                        let value = row[headerIndex] || '';
                        obj[header.trim()] = value;
                    }
                });
                return obj;
            });
            
            // Filter out completely empty rows
            const filteredRows = processedRows.filter(row => {
                return Object.values(row).some(value => value && String(value).trim() !== '');
            });
            
            console.log('Final processed rows:', filteredRows.length);
            
            return {
                headers: headers.filter(h => h && h.trim()), // Filter out empty headers
                data: filteredRows
            };
        }

        function extractAnalytes(processedData) {
            const headers = processedData.headers;
            console.log('Extracting analytes from headers:', headers);
            
            try {
                // Find Sample column (case-insensitive)
                let sampleIndex = -1;
                let totalEventsIndex = -1;
                
                for (let i = 0; i < headers.length; i++) {
                    const header = String(headers[i]).toLowerCase().trim();
                    if (header === 'sample') {
                        sampleIndex = i;
                    }
                    if (header === 'total events' || header === 'totalevents') { // Common variations
                        totalEventsIndex = i;
                    }
                }
                
                console.log('Found indices - Sample:', sampleIndex, 'Total Events:', totalEventsIndex);
                
                if (sampleIndex === -1) {
                    // Try another common name for sample column
                    sampleIndex = headers.findIndex(h => String(h).toLowerCase().trim().includes("well") && String(h).toLowerCase().trim().includes("id"));
                     if (sampleIndex === -1) {
                        throw new Error("CSV must contain a 'Sample' or 'Well ID' column. Found headers: " + headers.join(', '));
                    }
                }
                
                if (totalEventsIndex === -1) {
                    // If 'Total Events' is not found, try to infer the end of analyte block
                    // This is less reliable. Assuming analytes are before a known non-analyte column if 'Total Events' is missing.
                    // For now, we'll keep it strict as per original logic.
                    // If you often encounter files without 'Total Events', this part might need a heuristic.
                    // One heuristic: analytes are typically numeric columns after 'Sample' and before other metadata-like columns.
                    // For now, let's look for 'Bead ID' as an alternative end marker if 'Total Events' is missing
                    totalEventsIndex = headers.findIndex(h => String(h).toLowerCase().trim() === 'bead id');
                    if (totalEventsIndex === -1) {
                         // Fallback: assume analytes are all columns between 'Sample' and the first column that's clearly not an MFI value
                         // This is very heuristic. A better approach is to ensure 'Total Events' is present or use a more robust end marker.
                         // For now, let's take all columns after sampleIndex if totalEventsIndex is not found, up to a reasonable limit.
                         // This part can be improved if the CSV structure varies significantly.
                         console.warn("'Total Events' column not found. Attempting to infer analyte range. This might be inaccurate.");
                         totalEventsIndex = headers.length; // Take all remaining as potential analytes (will be filtered later if not numeric)
                    }
                }
                
                const analyteHeaders = headers.slice(sampleIndex + 1, totalEventsIndex).filter(h => {
                    // Further filter to ensure these are likely analyte MFI columns
                    // Check if at least one data row has a numeric value for this header
                    if (!h || !h.trim()) return false; // Skip empty headers
                    return processedData.data.some(row => !isNaN(parseFloat(row[h])));
                });

                console.log('Extracted analyte headers:', analyteHeaders);
                
                if (analyteHeaders.length === 0) {
                    throw new Error("No analyte columns found between 'Sample' and 'Total Events' (or inferred end) columns, or columns are not numeric.");
                }
                
                return analyteHeaders;
            } catch (error) {
                console.error("Error extracting analytes: ", error.message, "Headers processed: ", headers);
                updateStatus("Error extracting analytes: " + error.message + ". Check console for details.", "error");
                throw new Error("Error extracting analytes: " + error.message);
            }
        }

        function updateAnalyteDropdown() {
            const select = document.getElementById('analyteSelect');
            select.innerHTML = '<option value="All">All Analytes</option>';
            
            analytes.forEach(analyte => {
                const option = document.createElement('option');
                option.value = analyte;
                option.textContent = analyte;
                select.appendChild(option);
            });
            
            select.disabled = false;
        }

        async function loadStandardsFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        const lines = text.split(/\r?\n/);
                        
                        // Parse CSV
                        const data = lines.map(line => {
                            return line.split(',').map(cell => cell.trim().replace(/^"|"$/g, ''));
                        });
                        
                        // Find headers
                        let headerRow = 0; // Assuming headers are on the first line
                        let headers = data[headerRow];
                        
                        // Convert to object format
                        const standardsMap = {};
                        for (let i = 1; i < data.length; i++) {
                            const row = data[i];
                            if (row.length >= 2 && row[0] && row[1]) { // Ensure Sample and Concentration exist
                                const sample = row[0].trim();
                                const concentration = parseFloat(row[1]);
                                if (!isNaN(concentration)) {
                                    standardsMap[sample] = concentration;
                                }
                            }
                        }
                        
                        console.log('Parsed standards:', standardsMap);
                        resolve(standardsMap);
                        
                    } catch (error) {
                        reject(new Error('Error parsing standards file: ' + error.message));
                    }
                };
                
                reader.onerror = function(error) {
                    reject(new Error('Error reading standards file: ' + error.message));
                };
                
                reader.readAsText(file);
            });
        }

        async function loadCutoffFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        const lines = text.split(/\r?\n/).filter(line => line.trim());
                        
                        // Parse CSV
                        const data = lines.map(line => {
                            return line.split(',').map(cell => cell.trim().replace(/^"|"$/g, ''));
                        });
                        
                        // Find headers (should have 'Analyte' and 'Cutoff' columns)
                        let headerRow = 0;
                        let headers = data[headerRow];
                        
                        // Find column indices
                        const analyteCol = headers.findIndex(h => h.toLowerCase().includes('analyte'));
                        const cutoffCol = headers.findIndex(h => h.toLowerCase().includes('cutoff'));
                        
                        if (analyteCol === -1 || cutoffCol === -1) {
                            reject(new Error('Cutoff file must have "Analyte" and "Cutoff" columns'));
                            return;
                        }
                        
                        // Convert to object format
                        const cutoffMap = {};
                        for (let i = 1; i < data.length; i++) {
                            const row = data[i];
                            if (row.length > Math.max(analyteCol, cutoffCol)) {
                                const analyte = row[analyteCol];
                                const cutoff = parseFloat(row[cutoffCol]);
                                
                                if (analyte && !isNaN(cutoff)) {
                                    cutoffMap[analyte] = cutoff;
                                }
                            }
                        }
                        
                        console.log('Cutoff data loaded:', cutoffMap);
                        resolve(cutoffMap);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = function() {
                    reject(new Error('Failed to read cutoff file'));
                };
                
                reader.readAsText(file);
            });
        }

        function mergeStandardsWithData(processedData, standardsMap) {
            console.log('Starting merge process...');
            console.log('Standards map:', standardsMap);
            console.log('Sample data preview:', processedData.data.slice(0, 5).map(row => ({sample: row.Sample || row.sample})));
            
            // Create a deep copy of the processed data
            const mergedData = {
                headers: [...processedData.headers],
                data: processedData.data.map(row => ({ ...row }))
            };
            
            // Add Concentration header if not already present
            if (!mergedData.headers.includes('Concentration')) {
                mergedData.headers.push('Concentration');
            }
            
            // Track merge statistics
            let mergeCount = 0;
            let standardsFound = [];
            
            // Merge concentration values into each row (like Python script line 283: df.merge(std_map, on='Sample', how='left'))
            mergedData.data.forEach(row => {
                const sampleName = row.Sample || row.sample;
                if (sampleName && standardsMap[sampleName]) {
                    row.Concentration = standardsMap[sampleName];
                    standardsFound.push(`${sampleName} -> ${standardsMap[sampleName]}`);
                    mergeCount++;
                    console.log(`Merged: ${sampleName} -> ${standardsMap[sampleName]}`);
                } else {
                    // Set to null for non-standards (like pandas left join)
                    row.Concentration = null;
                }
            });
            
            console.log(`Merge completed: ${mergeCount} standards matched`);
            console.log('Standards found:', standardsFound);
            console.log('Merged data structure:', mergedData);
            return mergedData;
        }

        function autoDetectStandards(processedData) {
            console.log('Auto-detecting standards from sample names...');
            
            // Create a deep copy of the processed data
            const mergedData = {
                headers: [...processedData.headers],
                data: processedData.data.map(row => ({ ...row }))
            };
            
            // Add Concentration header if not already present
            if (!mergedData.headers.includes('Concentration')) {
                mergedData.headers.push('Concentration');
            }
            
            // Extract standard samples (like Python script lines 288-289)
            const standardSamples = processedData.data.filter(row => {
                const sampleName = String(row.Sample || row.sample || '');
                return sampleName.includes('Standard'); // Python script is case-sensitive for 'Standard'
            });
            
            console.log(`Found ${standardSamples.length} standard samples:`, standardSamples.map(s => s.Sample || s.sample));
            
            // Create concentration mapping (like Python script lines 291-299)
            const standardConcentrations = {};
            standardSamples.forEach(row => {
                const sampleName = String(row.Sample || row.sample || '');
                try {
                    // Extract number from "StandardN" format
                    const stdNumMatch = sampleName.match(/Standard(\d+)/i); // Case-insensitive match for "Standard" + number
                    if (stdNumMatch && stdNumMatch[1]) {
                        const stdNum = parseInt(stdNumMatch[1]);
                         // Set concentration based on standard number (same formula as Python)
                        // std_conc[sample] = 10 ** (5 - 0.5 * (std_num - 1))
                        const concentration = Math.pow(10, 5 - 0.5 * (stdNum - 1));
                        standardConcentrations[sampleName] = concentration;
                        console.log(`Auto-assigned: ${sampleName} -> ${concentration}`);
                    } else {
                         standardConcentrations[sampleName] = null; // Could not parse
                    }
                } catch (error) {
                    console.warn(`Could not parse standard number from: ${sampleName}`);
                    standardConcentrations[sampleName] = null;
                }
            });
            
            console.log('Auto-detected concentrations:', standardConcentrations);
            
            // Apply concentrations to merged data (like Python script df.merge)
            let assignedCount = 0;
            mergedData.data.forEach(row => {
                const sampleName = row.Sample || row.sample;
                if (sampleName && standardConcentrations.hasOwnProperty(sampleName)) {
                    row.Concentration = standardConcentrations[sampleName];
                    if (standardConcentrations[sampleName] !== null) {
                        assignedCount++;
                    }
                } else {
                    // Set to null for non-standards or if not detected as a standard (like pandas left join)
                    if(row.Concentration === undefined) row.Concentration = null;
                }
            });
            
            console.log(`Auto-detection completed: ${assignedCount} standards assigned concentrations`);
            
            // Print the inferred standard concentrations for debugging (like Python script lines 310-313)
            if (Object.keys(standardConcentrations).length > 0) {
                console.log('Inferred standard concentrations:');
                Object.entries(standardConcentrations).forEach(([sample, conc]) => {
                    console.log(`  ${sample}: ${conc}`);
                });
            }
            
            return mergedData;
        }

        async function validateAnalysisSetup() {
            if (!processedData || !processedData.data) {
                updateStatus('Please preprocess file first', 'error');
                return;
            }

            const validationDiv = document.getElementById('validationStatus');
            const detailsDiv = document.getElementById('validationDetails');
            
            validationDiv.style.display = 'block';
            detailsDiv.innerHTML = '<p>Validating analysis setup...</p>';
            
            let validationHTML = '';
            let allValid = true;
            
            // WORKAROUND: Use the clean CSV file that was generated correctly
            let dataToValidate = processedData.data;
            
            // Check if we have the clean data file and parse it directly
            const outputFolder = document.getElementById('outputFolder').value;
            const cleanDataKey = `${outputFolder}_clean_data.csv`;
            
            if (generatedFiles && generatedFiles[cleanDataKey]) {
                console.log('Using clean data file for validation instead of broken processedData');
                try {
                    // Parse the clean CSV directly
                    const cleanCSV = generatedFiles[cleanDataKey];
                    const lines = cleanCSV.split(/\r?\n/);
                    
                    // Parse CSV properly handling quoted fields
                    function parseCSVLine(line) {
                        const result = [];
                        let current = '';
                        let inQuotes = false;
                        
                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            
                            if (char === '"') {
                                inQuotes = !inQuotes;
                            } else if (char === ',' && !inQuotes) {
                                result.push(current.trim());
                                current = '';
                            } else {
                                current += char;
                            }
                        }
                        
                        // Add the last field
                        result.push(current.trim());
                        return result;
                    }
                    
                    const headers = parseCSVLine(lines[0]);
                    
                    dataToValidate = [];
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].trim()) {
                            const values = parseCSVLine(lines[i]);
                            const row = {};
                            headers.forEach((header, index) => {
                                row[header] = values[index] || '';
                            });
                            dataToValidate.push(row);
                        }
                    }
                    console.log('Successfully loaded clean data:', dataToValidate.length, 'samples');
                } catch (error) {
                    console.error('Error parsing clean CSV:', error);
                }
            }
            console.log('Validating data with', dataToValidate.length, 'samples');
            console.log('Headers in processed data:', processedData.headers);
            
            // Check if we have the right sample column name
            const sampleColumnName = processedData.headers.find(h => h && h.toLowerCase().trim() === 'sample');
            console.log('Sample column name found:', sampleColumnName);
            
            // 1. Check for standard samples in data
            const standardSamples = dataToValidate.filter(row => {
                // Try different ways to get the sample name
                const sampleName = String(row.Sample || row.sample || row[sampleColumnName] || '');
                return sampleName.includes('Standard') || sampleName.includes('standard') || 
                       sampleName.includes('Std') || sampleName.includes('std') ||
                       sampleName.includes('Cal') || sampleName.includes('cal');
            });
            
            console.log('Standards found during validation:', standardSamples.map(s => s.Sample || s.sample));
            
            if (standardSamples.length > 0) {
                validationHTML += `‚úÖ <strong>Standards Found:</strong> ${standardSamples.length} standard samples detected (${standardSamples.slice(0, 5).map(s => s.Sample || s.sample).join(', ')}${standardSamples.length > 5 ? '...' : ''})<br>`;
            } else {
                validationHTML += `‚ùå <strong>No Standards Found:</strong> No standard samples detected in data. Analysis will fail.<br>`;
                allValid = false;
            }
            
            // 2. Check standards file
            const standardsFile = document.getElementById('standardsFile').files[0];
            if (standardsFile) {
                try {
                    const standardsData = await loadStandardsFile(standardsFile);
                    const matchingStandards = standardSamples.filter(sample => {
                        const sampleName = sample.Sample || sample.sample;
                        return standardsData[sampleName] !== undefined;
                    });
                    
                    if (matchingStandards.length > 0) {
                        validationHTML += `‚úÖ <strong>Standards File:</strong> Loaded successfully. ${matchingStandards.length} standards will get concentrations from file.<br>`;
                    } else {
                        validationHTML += `‚ö†Ô∏è <strong>Standards File:</strong> Loaded but no sample names match. Auto-concentration will be used instead.<br>`;
                    }
                } catch (error) {
                    validationHTML += `‚ùå <strong>Standards File:</strong> Error loading file - ${error.message}<br>`;
                    allValid = false;
                }
            } else {
                if (standardSamples.length > 0) {
                    validationHTML += `‚ö†Ô∏è <strong>Standards File:</strong> Not provided. Auto-concentrations will be assigned based on sample names.<br>`;
                } else {
                    // This was too strict, if auto-detection works without a file, it's not an error.
                    // validationHTML += `‚ùå <strong>Standards File:</strong> Required since no standard samples detected in data.<br>`;
                    // allValid = false;
                     validationHTML += `‚ÑπÔ∏è <strong>Standards File:</strong> Not provided. Concentrations will be auto-detected if possible.<br>`;
                }
            }
            
            // 3. Check background sample
            const bgSample = document.getElementById('bgSample').value;
            const backgroundFound = dataToValidate.some(row => {
                const sampleName = String(row.Sample || row.sample || row[sampleColumnName] || '');
                return sampleName === bgSample;
            });
            
            console.log('Background search result:', backgroundFound, 'for sample:', bgSample);
            
            if (backgroundFound) {
                validationHTML += `‚úÖ <strong>Background Sample:</strong> "${bgSample}" found in data.<br>`;
            } else {
                validationHTML += `‚ö†Ô∏è <strong>Background Sample:</strong> "${bgSample}" not found in data. Background correction will be skipped (using raw MFI).<br>`;
            }
            
            // 4. Check cutoff file
            const cutoffFile = document.getElementById('cutoffFile').files[0];
            if (cutoffFile) {
                validationHTML += `‚úÖ <strong>Cutoff File:</strong> Loaded successfully.<br>`;
            } else {
                validationHTML += `‚ÑπÔ∏è <strong>Cutoff File:</strong> Not provided. No cutoff flags will be generated.<br>`;
            }
            
            // 5. Check dilution factor
            const dilutionFactor = parseFloat(document.getElementById('dilutionFactor').value);
            if (dilutionFactor > 0) {
                validationHTML += `‚úÖ <strong>Dilution Factor:</strong> ${dilutionFactor} (valid)<br>`;
            } else {
                validationHTML += `‚ùå <strong>Dilution Factor:</strong> Must be greater than 0.<br>`;
                allValid = false;
            }
            
            // 6. Check analytes
            if (analytes && analytes.length > 0) {
                validationHTML += `‚úÖ <strong>Analytes:</strong> ${analytes.length} analytes detected (${analytes.slice(0, 3).join(', ')}${analytes.length > 3 ? '...' : ''})<br>`;
            } else {
                validationHTML += `‚ùå <strong>Analytes:</strong> No analytes detected.<br>`;
                allValid = false;
            }
            
            // Summary
            if (allValid) {
                validationHTML += `<br><strong style="color: #28a745;">‚úÖ All validations passed! Ready for analysis.</strong>`;
                validationDiv.style.backgroundColor = '#d4edda';
                validationDiv.style.borderColor = '#c3e6cb';
            } else {
                validationHTML += `<br><strong style="color: #dc3545;">‚ùå Some validations failed. Please fix issues before running analysis.</strong>`;
                validationDiv.style.backgroundColor = '#f8d7da';
                validationDiv.style.borderColor = '#f5c6cb';
            }
            
            detailsDiv.innerHTML = validationHTML;
        }

        async function runAnalysis() {
            const selectedAnalyte = document.getElementById('analyteSelect').value;
            if (!selectedAnalyte) {
                updateStatus('Please select an analyte', 'error');
                return;
            }
            if (!processedData) {
                updateStatus('Please preprocess a file first.', 'error');
                return;
            }

            updateStatus('Running analysis...', 'info');
            updateProgress(0);
            
            // Clear previous charts from global array
            allCharts.length = 0;

            try {
                // Ensure Pyodide and packages are loaded before starting analysis loop
                await loadPyodideAndPackages();
                
                // Load and merge standards file if provided (like Python script does)
                let mergedData = null;
                const standardsFile = document.getElementById('standardsFile').files[0];
                if (standardsFile) {
                    updateStatus('Loading and merging standards file...', 'info');
                    const standardsData = await loadStandardsFile(standardsFile);
                    console.log('Standards loaded:', standardsData);
                    
                    // Merge standards with processed data (like Python script line 283)
                    mergedData = mergeStandardsWithData(processedData, standardsData);
                    console.log('Data merged with standards:', mergedData);
                } else {
                    // Auto-detect standards and assign concentrations (like Python script lines 286-314)
                    updateStatus('No standards file provided. Auto-detecting standard samples...', 'info');
                    
                    let dataForAnalysis = processedData;
                    const outputFolder = document.getElementById('outputFolder').value;
                    const cleanDataKey = `${outputFolder}_clean_data.csv`;
                    
                    if (generatedFiles && generatedFiles[cleanDataKey]) {
                        console.log('Using clean data file for analysis instead of potentially stale processedData');
                        try {
                            const cleanCSV = generatedFiles[cleanDataKey];
                            const lines = cleanCSV.split(/\r?\n/);
                            function parseCSVLine(line) { /* ... (same as in preprocessFile) ... */ 
                                const result = []; let current = ''; let inQuotes = false;
                                for (let i = 0; i < line.length; i++) {
                                    const char = line[i];
                                    if (char === '"') { inQuotes = !inQuotes; } 
                                    else if (char === ',' && !inQuotes) { result.push(current.trim()); current = ''; } 
                                    else { current += char; }
                                }
                                result.push(current.trim()); return result;
                            }
                            const headers = parseCSVLine(lines[0]);
                            const cleanData = [];
                            for (let i = 1; i < lines.length; i++) {
                                if (lines[i].trim()) {
                                    const values = parseCSVLine(lines[i]);
                                    const row = {};
                                    headers.forEach((header, index) => { row[header] = values[index] || ''; });
                                    cleanData.push(row);
                                }
                            }
                            dataForAnalysis = { headers: headers, data: cleanData };
                            console.log('Successfully loaded clean data for auto-standards analysis:', cleanData.length, 'samples');
                        } catch (error) {
                            console.error('Error parsing clean CSV for auto-standards analysis:', error);
                        }
                    }
                    
                    mergedData = autoDetectStandards(dataForAnalysis);
                    console.log('Standards auto-detected:', mergedData);
                }
                
                const analytesToProcess = selectedAnalyte === 'All' ? analytes : [selectedAnalyte];
                
                // Load cutoff file if provided (like Python script does)
                let cutoffData = null;
                const cutoffFile = document.getElementById('cutoffFile').files[0];
                if (cutoffFile) {
                    updateStatus('Loading cutoff file...', 'info');
                    try {
                        cutoffData = await loadCutoffFile(cutoffFile);
                        console.log('Cutoff data loaded:', cutoffData);
                    } catch (error) {
                        console.error('Error loading cutoff file:', error);
                        updateStatus('Warning: Failed to load cutoff file: ' + error.message, 'warning');
                    }
                }
                
                // Process each analyte
                for (let i = 0; i < analytesToProcess.length; i++) {
                    const analyte = analytesToProcess[i];
                    updateStatus(`Processing ${analyte}... (${i + 1}/${analytesToProcess.length})`, 'info');
                    updateProgress((i / analytesToProcess.length) * 90);
                    
                    // Perform analysis for this analyte using merged data
                    const result = await analyzeAnalyte(analyte, mergedData, cutoffData); // analyzeAnalyte is now async
                    analysisResults[analyte] = result;
                }
                
                updateProgress(95);
                
                // Show results section BEFORE generating charts to ensure proper canvas sizing
                document.getElementById('resultsSection').style.display = 'block';
                
                // Charts will be created in current tab - no auto switching
                // Wait for the browser to render the visible section and tab content
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Generate visualizations and files
                await generateResults();
                
                updateProgress(100);
                updateStatus('Analysis completed successfully!', 'success');
                
                // Show download section
                document.getElementById('downloadSection').style.display = 'block';
                
                // Enable global axis controls
                document.getElementById('globalXAxisToggle').disabled = false;
                document.getElementById('globalYAxisToggle').disabled = false;
                
            } catch (error) {
                updateStatus('Error during analysis: ' + error.message, 'error');
                console.error('Analysis error:', error);
            }
        }

        function filterLowStandards(standards, analyte, bgMean, bgStd) {
            // Filter out low standards that are too close to background noise
            // Uses balanced criteria: excludes standards in noise range but not overly stringent
            
            let filteredStandards = [...standards]; // Copy standards array
            let firstValidIdx = 0;
            let lowStdFiltered = false;
            
            // Sort standards by concentration to work from lowest to highest
            const sortedStandards = [...standards].sort((a, b) => a.concentration - b.concentration);
            
            // Calculate threshold for minimum acceptable signal
            // Use multiple criteria to determine if a standard is too close to background noise
            const bgVariability = bgStd > 0 ? bgStd * 2 : 0; // 2 standard deviations of background
            const minAbsoluteThreshold = 10; // Minimum 10 MFI (since background is already subtracted)
            const threshold = Math.max(bgVariability, minAbsoluteThreshold);
            
            // Find the first standard that meets our criteria
            for (let i = 0; i < sortedStandards.length; i++) {
                const std = sortedStandards[i];
                const correctedMfi = std.correctedMfi;
                
                // Balanced criteria for excluding low standards:
                // 1. Must have positive signal after background subtraction
                // 2. Must be above background noise threshold
                const hasPositiveSignal = correctedMfi > 0;
                const aboveNoiseThreshold = correctedMfi >= threshold;
                
                // 3. Check if this standard follows expected dose-response pattern
                let followsPattern = true;
                if (i >= 2) { // Need at least 3 points to check pattern
                    // Check if the trend is generally increasing with concentration
                    const prev2 = sortedStandards[i-2].correctedMfi;
                    const prev1 = sortedStandards[i-1].correctedMfi;
                    const current = correctedMfi;
                    
                    // Allow some flexibility - standard can be lower than previous if it's still above threshold
                    // But if it's dramatically lower (>50% drop), it might not fit the curve
                    if (current < prev1 * 0.5 && current < prev2 * 0.5) {
                        followsPattern = false;
                        console.log(`Standard ${i+1} for ${analyte} appears to deviate from dose-response pattern (MFI: ${current.toFixed(4)})`);
                    }
                }
                
                // Standard is valid if it meets all criteria
                if (hasPositiveSignal && aboveNoiseThreshold && followsPattern) {
                    firstValidIdx = i;
                    break;
                }
            }
            
            // Only filter if we're excluding low standards that don't meet our criteria
            if (firstValidIdx > 0) {
                filteredStandards = sortedStandards.slice(firstValidIdx);
                lowStdFiltered = true;
                console.log(`Filtering low standards for ${analyte}: excluding first ${firstValidIdx} standards (threshold: ${threshold.toFixed(4)} MFI, includes pattern-based filtering)`);
            } else {
                // No filtering needed - use all standards in their original order
                filteredStandards = standards;
            }
            
            // Ensure we still have enough standards for curve fitting
            if (filteredStandards.length < 4) {
                console.log(`Warning: Low standard filtering for ${analyte} would leave too few standards. Using top half instead.`);
                const halfway = Math.floor(standards.length / 2);
                filteredStandards = standards.slice(halfway);
                firstValidIdx = halfway;
                lowStdFiltered = true;
            }
            
            return {
                filteredStandards: filteredStandards,
                firstValidIdx: firstValidIdx,
                lod: threshold, // Return the threshold used for filtering
                lowStdFiltered: lowStdFiltered
            };
        }

        async function analyzeAnalyte(analyte, mergedData, cutoffData = null) { // Made async
            console.log(`Starting analysis for analyte: ${analyte}`);
            
            const bgSample = document.getElementById('bgSample').value;
            const dilutionFactor = parseFloat(document.getElementById('dilutionFactor').value);
            const detectHook = document.getElementById('detectHook').checked;
            const filterLowStd = document.getElementById('filterLowStd').checked;
            
            const analyteData = mergedData.data.map(row => {
                const sampleName = String(row.Sample || row.sample || '');
                let concentration = null;
                if (row.Concentration !== undefined && row.Concentration !== null && parseFloat(row.Concentration) > 0) {
                    concentration = parseFloat(row.Concentration);
                }
                
                return {
                    sample: sampleName,
                    location: row.Location || row.location || '',
                    mfi: parseFloat(row[analyte]) || 0,
                    concentration: concentration // This is expected_conc for standards
                };
            });
            
            console.log(`Found ${analyteData.length} samples for ${analyte}`);
            
            const standardsFound = analyteData.filter(row => row.concentration !== null && row.concentration > 0);
             if (standardsFound.length === 0) {
                const standardKeywords = ['standard', 'std', 'cal'];
                const alternativeStandards = analyteData.filter(row => {
                    const sampleName = String(row.sample || '').toLowerCase();
                    return standardKeywords.some(keyword => sampleName.includes(keyword));
                });
                
                let errorMsg = `No standards found for ${analyte}. `;
                if (alternativeStandards.length > 0) {
                    errorMsg += `Found samples like '${alternativeStandards[0].sample}' which might be standards, but they lack concentration values. `;
                    errorMsg += `Ensure your standards CSV (if provided) matches these names exactly (case-sensitive) or that auto-detection (e.g., 'Standard1') is applicable.`;
                } else {
                    errorMsg += `No samples found with names containing 'Standard', 'Std', or 'Cal'. Check data and/or standards CSV.`;
                }
                throw new Error(errorMsg);
            }
            
            // Background correction
            const backgroundData = analyteData.filter(row => row.sample === bgSample);
            let bgMean = 0;
            let bgStd = 0;
            
            if (backgroundData.length > 0) {
                bgMean = backgroundData.reduce((sum, row) => sum + row.mfi, 0) / backgroundData.length;
                if (backgroundData.length > 1) {
                    const variance = backgroundData.reduce((sum, row) => sum + Math.pow(row.mfi - bgMean, 2), 0) / (backgroundData.length - 1);
                    bgStd = Math.sqrt(variance);
                }
            } else {
                console.warn(`Background sample '${bgSample}' not found for ${analyte}. Using raw MFI (no background subtraction).`);
            }
            
            analyteData.forEach(row => {
                row.correctedMfi = row.mfi - bgMean;
            });
            
            const standards = analyteData.filter(row => row.concentration !== null && row.concentration > 0);
             if (standards.length < 4) { // SciPy needs at least 4 points for 4PL
                const detectedSamples = analyteData.slice(0, 10).map(row => `${row.sample}: ${row.concentration || 'No conc'}`).join(', ');
                throw new Error(`Not enough standards for ${analyte} to fit a 4PL curve. Found ${standards.length}, need at least 4. Sample preview: ${detectedSamples}. Check 'Concentration' column for standards.`);
            }
            
            standards.sort((a, b) => a.concentration - b.concentration);
            
            let hookResult = null;
            let hookDetected = false;
            let hookConc = NaN;
            let usableStandards = standards;
            
            if (detectHook && standards.length >= 4) {
                hookResult = identifyHookEffect(standards, analyte, 'correctedMfi');
                hookDetected = hookResult.hookPresent;
                hookConc = hookResult.hookConc;
                usableStandards = hookResult.hookPresent ? hookResult.sortedStandards.slice(0, hookResult.peakIdx + 1) : hookResult.sortedStandards;
            } else {
                 usableStandards = standards; // Use all if not detecting hook or too few standards
            }
            
            let filteredStandards = usableStandards;
            let firstValidIdx = 0;
            let lod = bgMean + (3 * bgStd);
            let lowStdFiltered = false;
            
            // Apply low standard filtering if enabled
            if (filterLowStd && usableStandards.length >= 4) {
                console.log(`Applying low standard filtering for ${analyte}`);
                const filterResult = filterLowStandards(usableStandards, analyte, bgMean, bgStd);
                filteredStandards = filterResult.filteredStandards;
                firstValidIdx = filterResult.firstValidIdx;
                lod = filterResult.lod;
                lowStdFiltered = filterResult.lowStdFiltered;
                
                if (lowStdFiltered) {
                    console.log(`Low standards filtered for ${analyte}. Using ${filteredStandards.length} out of ${usableStandards.length} standards.`);
                }
            } else {
                // Use all usable standards (default behavior)
                filteredStandards = usableStandards;
            }
             if (filteredStandards.length < 4) {
                 throw new Error(`Not enough standards (${filteredStandards.length}) remain for ${analyte} after filtering for curve fitting. Minimum 4 required.`);
             }
            
            const xData = filteredStandards.map(s => Math.log10(s.concentration));
            const yData = filteredStandards.map(s => s.correctedMfi);
            
            // Fit 4PL curve using Pyodide/SciPy
            const curveParams = await fit4PLCurve(xData, yData); // Await the async call
            console.log(`4PL fit parameters for ${analyte} (SciPy):`, curveParams);
            
            // Calculate concentrations for all samples
            analyteData.forEach(row => {
                if (row.concentration === null) { // Not a standard
                    row.calculatedConc = interpolateConcentration(row.correctedMfi, curveParams);
                    row.finalConc = row.calculatedConc !== null ? row.calculatedConc * dilutionFactor : null;
                } else { // It's a standard
                    row.calculatedConc = row.concentration; // Expected concentration for standards
                    row.finalConc = row.concentration; // Standards don't get dilution factor
                }
                
                const minStdMfi = Math.min(...filteredStandards.map(s => s.correctedMfi));
                const maxStdMfi = Math.max(...filteredStandards.map(s => s.correctedMfi));
                
                row.belowMinMfi = (row.correctedMfi < minStdMfi || row.correctedMfi < 0) ? 1 : 0;
                row.aboveMaxMfi = row.correctedMfi > maxStdMfi ? 1 : 0;
                
                if (hookDetected && detectHook) {
                    const hookPeakMfi = usableStandards[hookResult.peakIdx].correctedMfi;
                    row.inHookZone = (row.correctedMfi > hookPeakMfi || 
                                     (row.calculatedConc && row.calculatedConc > hookConc)) ? 1 : 0;
                } else {
                    row.inHookZone = 0;
                }
                
                // Calculate cutoff flag if cutoff data is provided
                if (cutoffData && cutoffData[analyte] !== undefined) {
                    const cutoffValue = cutoffData[analyte];
                    const isStandard = String(row.sample).toLowerCase().includes('standard');
                    const isBackground = row.sample === bgSample;
                    
                    if (isStandard) {
                        row.belowCutoff = null; // Standards get null for cutoff flag
                    } else if (isBackground) {
                        row.belowCutoff = 1; // Background samples are always below cutoff
                    } else {
                        // Regular samples: check if final concentration is below cutoff
                        row.belowCutoff = (row.finalConc !== null && row.finalConc < cutoffValue) ? 1 : 0;
                        
                        // Samples with MFI below min standard should automatically be below cutoff
                        if (row.belowMinMfi === 1) {
                            row.belowCutoff = 1;
                        }
                    }
                } else {
                    row.belowCutoff = null; // No cutoff provided
                }
            });
            
            const efficiencyData = calculateEfficiency(standards, analyte, curveParams); // Use all original standards for efficiency reporting
            
            return {
                analyte: analyte,
                data: analyteData,
                standards: filteredStandards, // Standards used in the fit
                allStandards: standards, // All standards initially identified
                usableStandards: usableStandards, // Standards after hook detection (if any)
                curveParams: curveParams,
                backgroundMean: bgMean,
                backgroundStd: bgStd,
                hookDetected: hookDetected,
                hookConcentration: hookConc,
                lowStandardsFiltered: lowStdFiltered,
                firstValidIndex: firstValidIdx,
                efficiencyData: efficiencyData,
                lod: lod
            };
        }
        
        async function fit4PLCurve(xData, yData) { // Made async
            if (!pyodideInstance) {
                console.warn("Pyodide not loaded. Attempting to load now for curve fitting.");
                await loadPyodideAndPackages(); // Ensure it's loaded
                if (!pyodideInstance) { // Check again after attempt
                    console.error("Pyodide failed to load. Curve fitting will use basic JS fallback (less accurate).");
                    updateStatus("Pyodide/SciPy failed to load. Using JS fallback for fitting.", "error");
                    // Fallback to a very simple estimation if Pyodide isn't available
                    const A0_fallback = Math.max(...yData, 0);
                    const D0_fallback = Math.min(...yData, 0);
                    const C0_fallback = xData.reduce((a, b) => a + b, 0) / xData.length;
                    return { A: A0_fallback, B: 1.0, C: C0_fallback, D: D0_fallback };
                }
            }
             if (xData.length < 4) {
                console.error("Not enough data points for 4PL fit (minimum 4). Using basic estimation.");
                updateStatus("Too few standards for robust 4PL fit. Results may be inaccurate.", "error");
                const A0_fallback = Math.max(...yData, 0);
                const D0_fallback = Math.min(...yData, 0);
                const C0_fallback = xData.reduce((a, b) => a + b, 0) / xData.length;
                return { A: A0_fallback, B: 1.0, C: C0_fallback, D: D0_fallback };
            }


            // Pass data to Pyodide global_ns
            pyodideInstance.globals.set('x_data_js', xData);
            pyodideInstance.globals.set('y_data_js', yData);

            const pythonCode = `
import numpy as np
from scipy.optimize import curve_fit
import js # To access console.log from Python

def four_pl_py(x, A, B, C, D):
    return D + (A - D) / (1 + 10**((C - x) * B))

x_data_py = np.array(x_data_js)
y_data_py = np.array(y_data_js)

# Initial guesses
y_data_py_finite = y_data_py[np.isfinite(y_data_py)]
x_data_py_finite = x_data_py[np.isfinite(x_data_py)]

if len(y_data_py_finite) == 0:
    A0_py, D0_py = 1.0, 0.0
else:
    A0_py = np.max(y_data_py_finite) if len(y_data_py_finite) > 0 else 1.0
    D0_py = np.min(y_data_py_finite) if len(y_data_py_finite) > 0 else 0.0

if len(x_data_py_finite) == 0:
    C0_py = 0.0
else:
    C0_py = np.median(x_data_py_finite)
B0_py = 1.0 

# Ensure A0_py is greater than D0_py for initial guess stability
if D0_py >= A0_py:
    if A0_py == D0_py : # if they are equal
        D0_py = A0_py - 0.1 if A0_py > 0 else -0.1
        A0_py = D0_py + 0.2 if D0_py > -0.1 else A0_py + 0.1 # ensure A0 is slightly larger
    else: # D0_py > A0_py, swap them
        A0_py, D0_py = D0_py, A0_py


p0_py = [A0_py, B0_py, C0_py, D0_py]

# Parameter bounds
min_x_py = np.min(x_data_py_finite) if len(x_data_py_finite) > 0 else -10.0
max_x_py = np.max(x_data_py_finite) if len(x_data_py_finite) > 0 else 10.0

# Define bounds carefully
# A (top) must be > D (bottom)
lower_A = D0_py 
upper_D = A0_py 

lower_bounds_py = [
    lower_A,    # A
    0.01,       # B (Hill slope) > 0
    min_x_py,   # C (inflection)
    -np.inf,    # D (bottom asymptote can be anything theoretically less than A)
]
upper_bounds_py = [
    np.inf,     # A 
    10.0,       # B
    max_x_py,   # C
    upper_D,    # D must be < A
]

# Clip initial parameters to be within bounds, adjust bounds if p0 is outside
for i in range(4):
    if p0_py[i] < lower_bounds_py[i]:
        p0_py[i] = lower_bounds_py[i]
    if p0_py[i] > upper_bounds_py[i]:
        p0_py[i] = upper_bounds_py[i]

# Ensure A_lower < A_upper and D_lower < D_upper, and A_lower > D_upper etc.
if lower_bounds_py[0] >= upper_bounds_py[0]: # A_lower >= A_upper
    upper_bounds_py[0] = lower_bounds_py[0] + abs(lower_bounds_py[0] * 0.1) + 0.1 
if lower_bounds_py[3] >= upper_bounds_py[3]: # D_lower >= D_upper
    lower_bounds_py[3] = upper_bounds_py[3] - abs(upper_bounds_py[3] * 0.1) - 0.1

if lower_bounds_py[0] <= lower_bounds_py[3]: # A_lower <= D_lower
    lower_bounds_py[3] = lower_bounds_py[0] - abs(lower_bounds_py[0]*0.1) -0.1 # make D_lower smaller

if upper_bounds_py[0] <= upper_bounds_py[3]: # A_upper <= D_upper
    upper_bounds_py[0] = upper_bounds_py[3] + abs(upper_bounds_py[3]*0.1) + 0.1 # make A_upper larger


# Final check on p0 relative to bounds after adjustments
p0_py[0] = np.clip(p0_py[0], lower_bounds_py[0], upper_bounds_py[0]) # A
p0_py[3] = np.clip(p0_py[3], lower_bounds_py[3], upper_bounds_py[3]) # D


popt_py = None
try:
    if len(x_data_py) < 4:
        js.console.error("Python: Not enough data points for 4PL fit (minimum 4).")
        popt_py = p0_py # Return initial guess as fallback
    else:
        popt_py, pcov = curve_fit(
            four_pl_py, x_data_py, y_data_py, p0=p0_py,
            bounds=(lower_bounds_py, upper_bounds_py),
            method='trf', # Trust Region Reflective, good for bounds
            maxfev=20000
        )
except RuntimeError as e:
    js.console.error(f"Python curve_fit RuntimeError: {e}. Params: p0={p0_py}, bounds=({lower_bounds_py}, {upper_bounds_py})")
    popt_py = p0_py # Fallback to initial guess
except ValueError as e:
    js.console.error(f"Python curve_fit ValueError: {e}. Params: p0={p0_py}, bounds=({lower_bounds_py}, {upper_bounds_py})")
    popt_py = p0_py # Fallback to initial guess

if popt_py is not None:
    popt_list_py = popt_py.tolist() if hasattr(popt_py, 'tolist') else list(popt_py)
else: # Should not happen if fallback is used
    popt_list_py = p0_py 

popt_list_py # This is returned to JavaScript
            `;

            try {
                updateStatus('Fitting 4PL curve using SciPy...', 'info');
                let popt_proxy = await pyodideInstance.runPythonAsync(pythonCode);
                let popt_js = popt_proxy.toJs ? popt_proxy.toJs() : popt_proxy; // Convert PyProxy to JS array

                if (!popt_js || popt_js.length !== 4 || popt_js.some(val => typeof val !== 'number' || isNaN(val))) {
                     console.error('SciPy curve_fit failed or returned invalid/NaN parameters. popt_js:', popt_js);
                     updateStatus('SciPy curve_fit failed to converge or returned invalid values. Using initial estimates.', 'error');
                     return { A: yData.length > 0 ? Math.max(...yData) : 1, B: 1.0, C: xData.length > 0 ? xData.reduce((a, b) => a + b, 0) / xData.length : 0, D: yData.length > 0 ? Math.min(...yData) : 0 }; // Fallback
                }
                updateStatus('4PL curve fitted successfully with SciPy.', 'success');
                return { A: popt_js[0], B: popt_js[1], C: popt_js[2], D: popt_js[3] };
            } catch (error) {
                console.error("Error during Pyodide execution for curve fitting: ", error);
                updateStatus(`Error fitting curve with SciPy: ${error}. Using JS fallback.`, 'error');
                const A0_fb = Math.max(...yData, 0); const D0_fb = Math.min(...yData, 0);
                const C0_fb = xData.reduce((a,b) => a+b,0)/xData.length;
                return { A: A0_fb, B: 1.0, C: C0_fb, D: D0_fb }; // Basic fallback
            }
        }
        
        function interpolateConcentration(mfi, params) {
            const { A, B, C, D } = params;
             // Check if params are valid numbers
            if ([A, B, C, D].some(p => typeof p !== 'number' || isNaN(p))) {
                console.warn("Invalid parameters for interpolation:", params);
                return null;
            }
            
            // Invert the 4PL equation to get concentration from MFI
            if (mfi <= D || mfi >= A) { // Strict inequality for mfi >= A if B is positive
                 if (mfi <= D && D < A) return Math.pow(10, C - (1/B) * Math.log10((A-D)/(D + 1e-9 - D)-1)); // very low conc
                 if (mfi >= A && A > D) return Math.pow(10, C - (1/B) * Math.log10((A-D)/(A - 1e-9 - D)-1)); // very high conc
                return null; 
            }
            
            const ratio = (A - D) / (mfi - D) - 1;
            if (ratio <= 0) { // This can happen if mfi is very close to A or D
                // If mfi is slightly above D, ratio is large, log10(ratio) is large, C - large_val * (1/B) = very negative logConc
                // If mfi is slightly below A, ratio is small positive, log10(ratio) is very negative, C - very_neg_val * (1/B) = very positive logConc
                // This condition (ratio <= 0) suggests mfi is outside the D to A range, or exactly D or A.
                // It might indicate an issue if mfi was already checked to be within (D, A).
                // Let's assume if ratio is very small (mfi close to A), conc is high. If ratio is very large (mfi close to D), conc is low.
                if (mfi > D && mfi < A) { // Should not happen if logic is correct
                     console.warn(`Interpolation issue: ratio is ${ratio} for MFI ${mfi} with params A:${A}, D:${D}`);
                }
                return null;
            }
            
            const logConc = C - (1 / B) * Math.log10(ratio);
            if (isNaN(logConc) || !isFinite(logConc)) return null;

            return Math.pow(10, logConc);
        }

        function calculateEfficiency(standards, analyte, curveParams) {
            // Calculate efficiency for each standard - matches Python logic from lines 404-417
            // First calculate interpolated concentrations for all standards
            const standardsWithConc = standards.map(std => {
                const interpolatedConc = interpolateConcentration(std.correctedMfi, curveParams);
                return {
                    ...std,
                    interpolatedConc: interpolatedConc
                };
            });
            
            // Calculate efficiency as (interpolated concentration / expected concentration) * 100
            // Group by expected concentration and calculate mean efficiency for each dilution level
            const efficiencyMap = new Map();
            
            standardsWithConc.forEach(std => {
                if (std.interpolatedConc !== null && std.concentration > 0) {
                    const efficiency = (std.interpolatedConc / std.concentration) * 100;
                    
                    if (!efficiencyMap.has(std.concentration)) {
                        efficiencyMap.set(std.concentration, []);
                    }
                    efficiencyMap.get(std.concentration).push(efficiency);
                } else {
                     // Could not interpolate or no expected concentration
                     if (!efficiencyMap.has(std.concentration)) {
                        efficiencyMap.set(std.concentration, []); // Store empty if cannot calculate
                    }
                }
            });
            
            // Calculate mean efficiency for each concentration level
            const efficiencyData = [];
            efficiencyMap.forEach((efficiencies, concentration) => {
                if (efficiencies.length > 0) {
                    const meanEfficiency = efficiencies.reduce((sum, eff) => sum + eff, 0) / efficiencies.length;
                    efficiencyData.push({
                        concentration: concentration,
                        efficiency: meanEfficiency
                    });
                } else {
                     efficiencyData.push({ // Push NaN or some indicator if no valid efficiencies
                        concentration: concentration,
                        efficiency: NaN 
                    });
                }
            });
            
            // Sort by concentration
            return efficiencyData.sort((a, b) => a.concentration - b.concentration);
        }
        
        function invertLogFourPl(y, A, B, C, D) { // Not directly used by SciPy fit, but used by JS efficiency calc if needed
            // Invert 4PL to compute log10 concentration from MFI - matches Python logic from lines 20-26
            if (y <= D || y >= A) { // if y is outside the asymptotes
                return NaN; // Outside valid range
            }
            
            const ratio = (A - D) / (y - D) - 1;
            if (ratio <= 0) { // if y equals A, or y is outside (D,A) range in a way that makes ratio non-positive
                return NaN;
            }
            
            const logx = C - (1.0 / B) * Math.log10(ratio);
            return logx;
        }

        async function generateResults() { // Made async
            // Clear previous results
            document.getElementById('graphsContainer').innerHTML = '';
            document.getElementById('dataTablesContainer').innerHTML = '';
            document.getElementById('iqcChartsContainer').innerHTML = '';
            document.getElementById('iqcTablesContainer').innerHTML = '';
            document.getElementById('summaryContainer').innerHTML = '';
            
            // Clear previous charts from global array
            allCharts.length = 0;
            // Don't reset generatedFiles here if preprocessing files are to be kept for download all
            // generatedFiles = {}; // This was here, moved a more specific reset if needed for analysis results only

            const outputFolder = document.getElementById('outputFolder').value;
            // Clear only analysis-specific files from generatedFiles if needed, or manage by prefix
            Object.keys(generatedFiles).forEach(key => {
                if (!key.startsWith(`${outputFolder}_clean_data.csv`) && !key.startsWith(`${outputFolder}_leftover_data.csv`)) {
                    delete generatedFiles[key];
                }
            });


            // Generate graphs for each analyte
            for (const [analyte, results] of Object.entries(analysisResults)) {
                await generateAnalyteGraphs(analyte, results); // Made async
                generateAnalyteDataTables(analyte, results);
            }
            
            // Generate IQC analysis
            generateIQCAnalysis();
            
            // Generate summary
            generateSummary();
            
            // Generate downloadable files
            await generateDownloadableFiles();
        }

        async function generateAnalyteGraphs(analyte, results) { // Made async
            const container = document.getElementById('graphsContainer');
            
            // Create graph container
            const graphDiv = document.createElement('div');
            graphDiv.className = 'graph-container';
            graphDiv.innerHTML = `<h3>${analyte} Standard Curve Analysis</h3>`;
            
            // Create charts row for side-by-side layout
            const chartsRow = document.createElement('div');
            chartsRow.className = 'charts-row';
            
            // Create standard curve canvas container
            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'chart-container half-width';
            
            const canvas = document.createElement('canvas');
            const sanitizedAnalyte = analyte.replace(/[^a-zA-Z0-9_-]/g, '_');
            canvas.id = `chart-${sanitizedAnalyte}`;
            canvasContainer.appendChild(canvas);
            chartsRow.appendChild(canvasContainer);
            graphDiv.appendChild(chartsRow);
            container.appendChild(graphDiv);
            
            // Wait for DOM insertion to complete before initializing Chart.js
            await new Promise(resolve => setTimeout(resolve, 50));
            
            // Generate standard curve chart
            const ctx = canvas.getContext('2d');
            
            console.log(`Generating graph for ${analyte}:`, results);
            
            // Prepare data for chart - show different categories of standards
            const allStandardData = results.allStandards.map(std => ({
                x: std.concentration,
                y: std.correctedMfi
            }));
            
            const usedStandardData = results.standards.map(std => ({ // Standards actually used in the fit
                x: std.concentration,
                y: std.correctedMfi
            }));
            
            // Identify excluded standards for visualization
            const excludedHookData = [];
            const excludedLowData = [];
            
            // Collect all concentrations used in the fit
            const fitConcs = new Set(results.standards.map(s => s.concentration));

            if (results.hookDetected) {
                // Standards that were part of "usableStandards" (after hook detection) but NOT in "filteredStandards" (final fit)
                // OR standards that were in "allStandards" but not in "usableStandards" due to hook
                results.allStandards.forEach(std => {
                    if (results.usableStandards.includes(std) && !fitConcs.has(std.concentration)) {
                        // This case might be complex if usableStandards were further filtered by low signal
                    }
                    // More simply: if hook was detected, any standard in allStandards with conc > hookConc
                    // AND was not part of the final fit set (results.standards)
                    if (std.concentration > results.hookConcentration && !fitConcs.has(std.concentration)) {
                         excludedHookData.push({ x: std.concentration, y: std.correctedMfi });
                    }
                });
            }
            
            if (results.lowStandardsFiltered) {
                // Standards that were part of "usableStandards" but excluded by low filter
                results.usableStandards.forEach(std => {
                    if (!fitConcs.has(std.concentration) && !excludedHookData.some(ex => ex.x === std.concentration)) { // Not already marked as hook-excluded
                        excludedLowData.push({ x: std.concentration, y: std.correctedMfi });
                    }
                });
            }
            
            // Generate fitted curve points - match Python logic for curve range (lines 524-538)
            const curvePoints = [];
            if (results.standards.length > 0 && results.curveParams && Object.values(results.curveParams).every(p => isFinite(p))) {
                let xMinLog, xMaxLog;
                
                const fitStandardConcs = results.standards.map(s => s.concentration).filter(c => c > 0);
                if (fitStandardConcs.length === 0) {
                     console.warn("No valid positive concentrations in standards used for fit. Cannot generate curve points.");
                } else {
                    const minFitConc = Math.min(...fitStandardConcs);
                    const maxFitConc = Math.max(...fitStandardConcs);

                    if (results.hookDetected && isFinite(results.hookConcentration) && results.hookConcentration > 0) {
                        xMinLog = Math.log10(minFitConc);
                        xMaxLog = Math.log10(Math.min(maxFitConc, results.hookConcentration)); // Plot up to hook or max fitted std
                    } else {
                        xMinLog = Math.log10(minFitConc);
                        xMaxLog = Math.log10(maxFitConc);
                    }
                    
                    // Generate curve points with finer resolution for smooth curve
                    if (isFinite(xMinLog) && isFinite(xMaxLog) && xMinLog <= xMaxLog) {
                        for (let i = 0; i <= 200; i++) {
                            const logConc = xMinLog + (i / 200) * (xMaxLog - xMinLog);
                            const conc = Math.pow(10, logConc);
                            const mfi = fourPL(logConc, results.curveParams); // JS fourPL
                            if (isFinite(mfi)) { // Only add valid points
                                curvePoints.push({ x: conc, y: mfi });
                            }
                        }
                    } else {
                         console.warn(`Cannot generate curve points for ${analyte} due to invalid xMinLog/xMaxLog. Min/Max fit conc: ${minFitConc}/${maxFitConc}, HookConc: ${results.hookConcentration}`);
                    }
                }
            } else {
                 console.warn(`Not generating curve for ${analyte} due to insufficient standards or invalid curve params.`);
            }
            
            
            // Build datasets dynamically based on what exclusions occurred
            const datasets = [];
            
            // Standards used in fit (always shown)
            datasets.push({
                label: 'Standards (Used in Fit)',
                data: usedStandardData,
                backgroundColor: 'rgba(102, 126, 234, 0.8)', // Blue
                borderColor: 'rgba(102, 126, 234, 1)',
                pointRadius: 8
            });
            
            // Standards excluded due to hook effect
            if (excludedHookData.length > 0) {
                datasets.push({
                    label: 'Standards (Excluded - Hook Effect)',
                    data: excludedHookData,
                    backgroundColor: 'rgba(128, 128, 128, 0.6)', // Grey
                    borderColor: 'rgba(100, 100, 100, 1)',
                    pointRadius: 6,
                    pointStyle: 'crossRot' // Changed style
                });
            }
            
            // Standards excluded due to low signal
            if (excludedLowData.length > 0) {
                datasets.push({
                    label: 'Standards (Excluded - Low Signal)',
                    data: excludedLowData,
                    backgroundColor: 'rgba(255, 165, 0, 0.6)', // Orange
                    borderColor: 'rgba(255, 140, 0, 1)',
                    pointRadius: 6,
                    pointStyle: 'triangle' // Changed style
                });
            }
            
            // Other standards (not used in fit, not explicitly excluded by hook/low)
            const displayedConcs = new Set([
                ...usedStandardData.map(d => d.x),
                ...excludedHookData.map(d => d.x),
                ...excludedLowData.map(d => d.x)
            ]);
            const otherStandardData = allStandardData.filter(d => !displayedConcs.has(d.x));
            if (otherStandardData.length > 0) {
                datasets.push({
                    label: 'Standards (Other/Not in Fit)',
                    data: otherStandardData,
                    backgroundColor: 'rgba(200, 200, 200, 0.4)', // Lighter Grey
                    borderColor: 'rgba(150, 150, 150, 1)',
                    pointRadius: 5,
                    pointStyle: 'rect'
                });
            }
            
            // Fitted curve
            if (curvePoints.length > 0) {
                datasets.push({
                    label: '4PL Fit (SciPy)',
                    data: curvePoints,
                    type: 'line',
                    borderColor: 'rgba(255, 99, 132, 1)', // Red
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    pointRadius: 0,
                    fill: false,
                    tension: 0.1 // Slight tension for smoothness
                });
            }

            const chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index', // Show tooltips for all points at the same x-value
                        intersect: false
                    },
                    animation: {
                        duration: 0 // Disable animations
                    },
                    scales: {
                        x: {
                            type: globalXAxisLog ? 'logarithmic' : 'linear',
                            title: {
                                display: true,
                                text: globalXAxisLog ? 'Concentration (Log Scale)' : 'Concentration (Linear Scale)'
                            },
                            grid: {
                                display: true
                            }
                        },
                        y: {
                            type: globalYAxisLog ? 'logarithmic' : 'linear',
                            title: {
                                display: true,
                                text: globalYAxisLog ? 'Corrected MFI (Log Scale)' : 'Corrected MFI (Linear Scale)'
                            },
                            beginAtZero: false, // Don't force start at zero, especially if MFIs can be negative
                            grid: {
                                display: true
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Standard Curve for ${analyte}`
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.x !== null) {
                                        label += `Conc: ${formatNumber(context.parsed.x)}`;
                                    }
                                    if (context.parsed.y !== null) {
                                        label += `, MFI: ${formatNumber(context.parsed.y)}`;
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
            
            // Add chart to global array for axis control and export
            const chartInfo = {
                chart: chart,
                canvas: canvas,
                analyte: analyte,
                filename: `${analyte}_standard_curve.png`,
                type: 'standard_curve'
            };
            allCharts.push(chartInfo);
            console.log(`Added standard curve chart to allCharts: ${analyte}`, chartInfo);
            
            // Force chart to render and resize properly and wait for it
            await new Promise(resolve => {
                setTimeout(() => {
                    // Force multiple resize attempts to ensure proper dimensions
                    if (chart && typeof chart.update === 'function') {
                        chart.update('none'); // Force update
                    }
                    if (chart && typeof chart.resize === 'function') {
                        chart.resize();
                    }
                    
                    // Additional forced render
                    if (chart && typeof chart.render === 'function') {
                        chart.render();
                    }
                    
                    // Check if canvas got proper dimensions
                    console.log(`Chart rendered and resized for ${analyte}: ${canvas.width}x${canvas.height}`);
                    
                    // If canvas still has 0 dimensions, try another resize
                    if (canvas.width === 0 || canvas.height === 0) {
                        console.warn(`Canvas has 0 dimensions for ${analyte}, attempting additional resize...`);
                        setTimeout(() => {
                            if (chart && typeof chart.resize === 'function') {
                                chart.resize();
                            }
                            resolve();
                        }, 200);
                    } else {
                        resolve();
                    }
                }, 500); // Increased delay to ensure proper rendering
            });
            
            // Create efficiency chart next to standard curve
            await createEfficiencyChart(analyte, results, chartsRow);
            
            // Add curve parameters text
            const paramsDiv = document.createElement('div');
            paramsDiv.style.marginTop = '10px';
            paramsDiv.style.fontSize = '14px';
            
            let paramsHTML = `
                <strong>4PL Parameters (SciPy Fit):</strong><br>
                A (Top): ${formatNumber(results.curveParams.A)}<br>
                B (Hill Slope): ${formatNumber(results.curveParams.B)}<br>
                C (Inflection, log10EC50): ${formatNumber(results.curveParams.C)}<br>
                D (Bottom): ${formatNumber(results.curveParams.D)}<br>
                Background Mean: ${formatNumber(results.backgroundMean)}<br>
                Standards Used in Fit: ${results.standards.length} / ${results.allStandards.length}
            `;
            
            if (results.hookDetected) {
                paramsHTML += `<br><strong style="color: #d63384;">Hook Effect Detected</strong><br>`;
                paramsHTML += `Hook Concentration (approx.): ${formatNumber(results.hookConcentration)}<br>`;
            }
            
            if (results.lowStandardsFiltered) {
                paramsHTML += `<br><strong style="color: #fd7e14;">Low Standards Filtered Out</strong><br>`;
                paramsHTML += `Filtering threshold: ${formatNumber(results.lod)} MFI<br>`;
            }
            
            paramsDiv.innerHTML = paramsHTML;
            graphDiv.appendChild(paramsDiv);
        }

        async function createEfficiencyChart(analyte, results, chartsRow) {
            // Only create efficiency chart if we have efficiency data
            if (!results.efficiencyData || results.efficiencyData.length === 0) {
                return;
            }
            
            // Filter to only used standards (those that were actually fit)
            const usedStandardConcs = new Set(results.standards.map(s => s.concentration));
            const usedEfficiencyData = results.efficiencyData.filter(e => 
                usedStandardConcs.has(e.concentration) && isFinite(e.efficiency)
            );
            
            if (usedEfficiencyData.length === 0) {
                return;
            }
            
            // Create efficiency chart container (half width to be side by side)
            const efficiencyContainer = document.createElement('div');
            efficiencyContainer.className = 'chart-container half-width';
            
            const efficiencyCanvas = document.createElement('canvas');
            const sanitizedAnalyte = analyte.replace(/[^a-zA-Z0-9_-]/g, '_');
            efficiencyCanvas.id = `efficiency-chart-${sanitizedAnalyte}`;
            efficiencyContainer.appendChild(efficiencyCanvas);
            chartsRow.appendChild(efficiencyContainer);
            
            // Wait for DOM insertion
            await new Promise(resolve => setTimeout(resolve, 50));
            
            // Prepare efficiency data for chart
            const efficiencyPoints = usedEfficiencyData.map(e => ({
                x: e.concentration,
                y: e.efficiency
            }));
            
            // Calculate average efficiency line
            const avgEfficiency = usedEfficiencyData.reduce((sum, e) => sum + e.efficiency, 0) / usedEfficiencyData.length;
            
            // Create horizontal line data for average efficiency and 100% reference
            const minConc = Math.min(...usedEfficiencyData.map(e => e.concentration));
            const maxConc = Math.max(...usedEfficiencyData.map(e => e.concentration));
            const avgLineData = [
                { x: minConc, y: avgEfficiency },
                { x: maxConc, y: avgEfficiency }
            ];
            const hundredPercentLineData = [
                { x: minConc, y: 100 },
                { x: maxConc, y: 100 }
            ];
            
            const datasets = [
                {
                    label: 'Standard Efficiency (%)',
                    data: efficiencyPoints,
                    backgroundColor: 'rgba(75, 192, 192, 0.6)',
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 2,
                    pointRadius: 6,
                    pointHoverRadius: 8,
                    showLine: false
                },
                {
                    label: `Average Efficiency (${avgEfficiency.toFixed(4)}%)`,
                    data: avgLineData,
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    showLine: true,
                    fill: false,
                    tension: 0
                }
            ];
            
            const efficiencyChart = new Chart(efficiencyCanvas.getContext('2d'), {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0
                    },
                    scales: {
                        x: {
                            type: globalXAxisLog ? 'logarithmic' : 'linear',
                            title: {
                                display: true,
                                text: globalXAxisLog ? 'Concentration (Log Scale)' : 'Concentration (Linear Scale)'
                            },
                            grid: {
                                display: true
                            }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Efficiency (%)'
                            },
                            beginAtZero: false,
                            grid: {
                                display: true
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Standard Curve Efficiency for ${analyte}`
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.x !== null) {
                                        label += `Conc: ${formatNumber(context.parsed.x)}`;
                                    }
                                    if (context.parsed.y !== null) {
                                        label += `, Efficiency: ${formatNumber(context.parsed.y)}%`;
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    plugins: [{
                        // Custom plugin to draw 100% reference line without adding to legend
                        afterDraw: function(chart) {
                            const ctx = chart.ctx;
                            const chartArea = chart.chartArea;
                            const yScale = chart.scales.y;
                            
                            // Get y-coordinate for 100%
                            const y100 = yScale.getPixelForValue(100);
                            
                            // Only draw if 100% is within the visible chart area
                            if (y100 >= chartArea.top && y100 <= chartArea.bottom) {
                                ctx.save();
                                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                ctx.lineWidth = 1;
                                ctx.setLineDash([10, 5]);
                                
                                ctx.beginPath();
                                ctx.moveTo(chartArea.left, y100);
                                ctx.lineTo(chartArea.right, y100);
                                ctx.stroke();
                                
                                ctx.restore();
                            }
                        }
                    }]
                }
            });
            
            // Add efficiency chart to global array for axis control and export
            const chartInfo = {
                chart: efficiencyChart,
                canvas: efficiencyCanvas,
                analyte: analyte,
                filename: `${analyte}_efficiency.png`,
                type: 'efficiency'
            };
            allCharts.push(chartInfo);
            console.log(`Added efficiency chart to allCharts: ${analyte}`, chartInfo);
            
            // Force chart to render properly
            await new Promise(resolve => {
                setTimeout(() => {
                    if (efficiencyChart && typeof efficiencyChart.update === 'function') {
                        efficiencyChart.update('none');
                    }
                    if (efficiencyChart && typeof efficiencyChart.resize === 'function') {
                        efficiencyChart.resize();
                    }
                    if (efficiencyChart && typeof efficiencyChart.render === 'function') {
                        efficiencyChart.render();
                    }
                    
                    console.log(`Efficiency chart rendered for ${analyte}: ${efficiencyCanvas.width}x${efficiencyCanvas.height}`);
                    
                    if (efficiencyCanvas.width === 0 || efficiencyCanvas.height === 0) {
                        console.warn(`Efficiency canvas has 0 dimensions for ${analyte}, attempting additional resize...`);
                        setTimeout(() => {
                            if (efficiencyChart && typeof efficiencyChart.resize === 'function') {
                                efficiencyChart.resize();
                            }
                            resolve();
                        }, 200);
                    } else {
                        resolve();
                    }
                }, 500);
            });
        }

        function fourPL(logX, params) { // JavaScript version of 4PL for plotting
            const { A, B, C, D } = params;
            if ([A,B,C,D].some(p => typeof p !== 'number' || isNaN(p))) return NaN;
            return D + (A - D) / (1 + Math.pow(10, (C - logX) * B));
        }

        function identifyHookEffect(standards, analyte, correctedCol) {
            // Get only rows with valid concentration and MFI values
            const validStandards = standards.filter(std => {
                const conc = parseFloat(std.concentration);
                const mfi = parseFloat(std[correctedCol]); // Use correctedCol passed as argument
                return conc > 0 && isFinite(conc) && mfi > -Infinity && isFinite(mfi); // Allow positive MFI
            });
            
            // If not enough valid points, return immediately
            if (validStandards.length < 3) {
                return {
                    sortedStandards: validStandards.sort((a, b) => a.concentration - b.concentration),
                    peakIdx: -1,
                    hookPresent: false,
                    hookConc: NaN
                };
            }
            
            // Sort by concentration (ascending)
            const sortedStandards = validStandards.sort((a, b) => a.concentration - b.concentration);
            
            // Find the peak MFI value
            let peakIdx = 0;
            let peakMfi = -Infinity;
            
            for (let i = 0; i < sortedStandards.length; i++) {
                if (sortedStandards[i][correctedCol] > peakMfi) {
                    peakMfi = sortedStandards[i][correctedCol];
                    peakIdx = i;
                }
            }
            
            const peakConc = sortedStandards[peakIdx].concentration;
            
            // Check if the peak is not at the highest concentration (possible hook effect)
            if (peakIdx < sortedStandards.length - 1) {
                // Check if MFI drops significantly after the peak
                // Consider MFI values for concentrations higher than the peak concentration
                let subsequentMFI = sortedStandards.slice(peakIdx + 1).map(s => s[correctedCol]);
                if (subsequentMFI.length > 0) {
                    // Check if any subsequent MFI is significantly lower than peakMfi
                    // A simple check: if the MFI at the highest concentration is < 90% of peakMFI
                    const lastMfi = sortedStandards[sortedStandards.length - 1][correctedCol];
                    if (lastMfi < peakMfi * 0.90 && peakMfi > 0) { // 10% drop relative to peak, ensure peak is positive
                        console.log(`Hook effect detected for ${analyte} at concentration ${peakConc}. Peak MFI: ${peakMfi}, Last MFI: ${lastMfi}`);
                        return {
                            sortedStandards,
                            peakIdx,
                            hookPresent: true,
                            hookConc: peakConc
                        };
                    }
                }
            }
            
            // No hook effect detected, use all standards
            console.log(`No hook effect detected for ${analyte}`);
            return {
                sortedStandards,
                peakIdx: sortedStandards.length - 1, // Peak is effectively the end or no drop seen
                hookPresent: false,
                hookConc: NaN
            };
        }


        function generateAnalyteDataTables(analyte, results) {
            const container = document.getElementById('dataTablesContainer');
            
            // Create table container
            const tableDiv = document.createElement('div');
            tableDiv.innerHTML = `<h3>${analyte} Results</h3>`;
            
            // Create table
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.style.margin = '1rem 0';
            
            // Table header
            const headerRow = table.insertRow();
            ['Sample', 'Location', 'Raw MFI', 'Corrected MFI', 'Calc. Conc', 'Final Conc', 'Below Min MFI', 'Below Cutoff', 'Above Max MFI', 'In Hook Zone'].forEach(text => {
                const th = document.createElement('th');
                th.textContent = text;
                th.style.border = '1px solid #ddd';
                th.style.padding = '8px';
                th.style.backgroundColor = '#f8f9fa';
                headerRow.appendChild(th);
            });
            
            // Table data - show all rows or a subset
            const dataToShow = results.data; // Or results.data.slice(0, N) for subset
            dataToShow.forEach(row => { 
                const dataRow = table.insertRow();
                [
                    row.sample,
                    row.location,
                    formatMfiConc(row.mfi),
                    formatMfiConc(row.correctedMfi),
                    formatMfiConc(row.calculatedConc),
                    formatMfiConc(row.finalConc),
                    row.belowMinMfi,
                    row.belowCutoff,
                    row.aboveMaxMfi,
                    row.inHookZone
                ].forEach(text => {
                    const td = document.createElement('td');
                    td.textContent = text;
                    td.style.border = '1px solid #ddd';
                    td.style.padding = '8px';
                    dataRow.appendChild(td);
                });
            });
            
            tableDiv.appendChild(table);
            container.appendChild(tableDiv);
        }

        function generateIQCAnalysis() {
            const chartsContainer = document.getElementById('iqcChartsContainer');
            const tablesContainer = document.getElementById('iqcTablesContainer');
            
            const allAnalytes = Object.keys(analysisResults);
            let totalIQCSamples = 0;
            let allIQCNames = new Set();
            
            // Check if any analytes have IQC samples
            allAnalytes.forEach(analyte => {
                const results = analysisResults[analyte];
                const iqcSamples = results.data.filter(row => {
                    if (!row.sample) return false;
                    const sampleStr = String(row.sample).toUpperCase();
                    return sampleStr.startsWith('IQC') || sampleStr.startsWith('CONTROL');
                });
                if (iqcSamples.length > 0) {
                    totalIQCSamples += iqcSamples.length;
                    iqcSamples.forEach(sample => allIQCNames.add(sample.sample));
                }
            });
            
            if (totalIQCSamples === 0) {
                chartsContainer.innerHTML = '<div style="padding: 2rem; text-align: center; color: #666;">No IQC or Control samples found in the data.</div>';
                return;
            }
            
            // Update IQC summary
            const summaryDiv = document.getElementById('iqcSummary');
            const uniqueNames = Array.from(allIQCNames).sort();
            summaryDiv.innerHTML = `
                <h3>Internal Quality Control (IQC) Analysis</h3>
                <p>Found ${uniqueNames.length} unique IQC sample type(s): <strong>${uniqueNames.join(', ')}</strong></p>
                <p>This section shows IQC analysis for each analyte individually, with mean ¬± SD calculated for duplicate samples.</p>
            `;
            
            // Process each analyte separately
            allAnalytes.forEach(analyte => {
                const results = analysisResults[analyte];
                const iqcSamples = results.data.filter(row => {
                    if (!row.sample) return false;
                    const sampleStr = String(row.sample).toUpperCase();
                    return sampleStr.startsWith('IQC') || sampleStr.startsWith('CONTROL');
                });
                
                if (iqcSamples.length === 0) return;
                
                // Group by sample name and calculate statistics
                const iqcGroups = new Map();
                iqcSamples.forEach(sample => {
                    const sampleName = sample.sample;
                    if (!iqcGroups.has(sampleName)) {
                        iqcGroups.set(sampleName, []);
                    }
                    iqcGroups.get(sampleName).push(sample);
                });
                
                // Calculate mean and SD for each group
                const iqcStats = [];
                iqcGroups.forEach((samples, sampleName) => {
                    const validConcs = samples
                        .map(s => s.finalConc)
                        .filter(c => c !== null && c !== undefined && isFinite(c));
                    
                    let mean = null;
                    let sd = null;
                    let cv = null;
                    
                    if (validConcs.length > 0) {
                        mean = validConcs.reduce((sum, c) => sum + c, 0) / validConcs.length;
                        if (validConcs.length > 1) {
                            const variance = validConcs.reduce((sum, c) => sum + Math.pow(c - mean, 2), 0) / (validConcs.length - 1);
                            sd = Math.sqrt(variance);
                            cv = mean !== 0 ? (sd / mean) * 100 : null;
                        }
                    }
                    
                    // Collect all unique locations for this sample group
                    const locations = [...new Set(samples.map(s => s.location || '').filter(loc => loc !== ''))];
                    const locationStr = locations.length > 0 ? locations.join(', ') : 'N/A';
                    
                    iqcStats.push({
                        sampleName: sampleName,
                        samples: samples,
                        n: samples.length,
                        mean: mean,
                        sd: sd,
                        cv: cv,
                        location: locationStr
                    });
                });
                
                // Create analyte section
                const analyteSection = document.createElement('div');
                analyteSection.style.marginBottom = '3rem';
                analyteSection.style.padding = '1rem';
                analyteSection.style.backgroundColor = '#f8f9fa';
                analyteSection.style.borderRadius = '8px';
                analyteSection.style.border = '1px solid #e0e0e0';
                
                const analyteTitle = document.createElement('h4');
                analyteTitle.textContent = `${analyte} - IQC Analysis`;
                analyteTitle.style.marginBottom = '1rem';
                analyteTitle.style.color = '#333';
                analyteSection.appendChild(analyteTitle);
                
                // Create data table for this analyte
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.backgroundColor = 'white';
                table.style.marginBottom = '1rem';
                
                // Table header
                const headerRow = document.createElement('tr');
                headerRow.style.backgroundColor = '#667eea';
                headerRow.style.color = 'white';
                
                const headers = ['Sample', 'n', 'Mean (pg/ml)', 'SD (pg/ml)', 'CV (%)', 'Location'];
                headers.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    th.style.border = '1px solid #ddd';
                    th.style.padding = '10px';
                    th.style.textAlign = 'center';
                    th.style.fontWeight = 'bold';
                    headerRow.appendChild(th);
                });
                table.appendChild(headerRow);
                
                // Data rows
                iqcStats.forEach(stat => {
                    const row = document.createElement('tr');
                    row.style.backgroundColor = 'white';
                    
                    // Sample name
                    const nameCell = document.createElement('td');
                    nameCell.textContent = stat.sampleName;
                    nameCell.style.border = '1px solid #ddd';
                    nameCell.style.padding = '8px';
                    nameCell.style.fontWeight = 'bold';
                    row.appendChild(nameCell);
                    
                    // n (sample count)
                    const nCell = document.createElement('td');
                    nCell.textContent = stat.n;
                    nCell.style.border = '1px solid #ddd';
                    nCell.style.padding = '8px';
                    nCell.style.textAlign = 'center';
                    row.appendChild(nCell);
                    
                    // Mean
                    const meanCell = document.createElement('td');
                    meanCell.textContent = stat.mean !== null ? formatNumber(stat.mean) : 'N/A';
                    meanCell.style.border = '1px solid #ddd';
                    meanCell.style.padding = '8px';
                    meanCell.style.textAlign = 'right';
                    row.appendChild(meanCell);
                    
                    // SD
                    const sdCell = document.createElement('td');
                    sdCell.textContent = stat.sd !== null ? formatNumber(stat.sd) : (stat.n > 1 ? 'N/A' : '-');
                    sdCell.style.border = '1px solid #ddd';
                    sdCell.style.padding = '8px';
                    sdCell.style.textAlign = 'right';
                    row.appendChild(sdCell);
                    
                    // CV
                    const cvCell = document.createElement('td');
                    cvCell.textContent = stat.cv !== null ? `${stat.cv.toFixed(4)}%` : (stat.n > 1 ? 'N/A' : '-');
                    cvCell.style.border = '1px solid #ddd';
                    cvCell.style.padding = '8px';
                    cvCell.style.textAlign = 'right';
                    // Color code CV
                    if (stat.cv !== null) {
                        if (stat.cv > 20) {
                            cvCell.style.backgroundColor = '#f8d7da';
                            cvCell.title = 'High variability (CV > 20%)';
                        } else if (stat.cv > 15) {
                            cvCell.style.backgroundColor = '#fff3cd';
                            cvCell.title = 'Moderate variability (CV > 15%)';
                        } else {
                            cvCell.style.backgroundColor = '#d4edda';
                            cvCell.title = 'Good reproducibility (CV ‚â§ 15%)';
                        }
                    }
                    row.appendChild(cvCell);
                    
                    // Location
                    const locationCell = document.createElement('td');
                    locationCell.textContent = stat.location || 'N/A';
                    locationCell.style.border = '1px solid #ddd';
                    locationCell.style.padding = '8px';
                    locationCell.style.textAlign = 'center';
                    row.appendChild(locationCell);
                    
                    table.appendChild(row);
                });
                
                analyteSection.appendChild(table);
                
                // Create separate charts for each IQC control level
                console.log(`IQC Stats for ${analyte}:`, iqcStats.length, iqcStats);
                if (iqcStats.length > 0) {
                    // Function to get color based on control number
                    function getControlColor(sampleName) {
                        const upperName = sampleName.toUpperCase();
                        if (upperName.includes('1')) return '#FF6B6B'; // Red for level 1
                        if (upperName.includes('2')) return '#4ECDC4'; // Blue for level 2  
                        if (upperName.includes('3')) return '#FFE66D'; // Yellow for level 3
                        return '#95A5A6'; // Gray for others
                    }
                    
                    // Create horizontal container for all IQC charts
                    const chartsRow = document.createElement('div');
                    chartsRow.style.display = 'flex';
                    chartsRow.style.gap = '1rem';
                    chartsRow.style.marginTop = '1rem';
                    chartsRow.style.flexWrap = 'wrap';
                    
                    // Create individual chart for each IQC type
                    iqcStats.forEach((stat, statIndex) => {
                        console.log(`Processing IQC chart ${statIndex + 1}/${iqcStats.length}: ${stat.sampleName}, mean: ${stat.mean}, samples: ${stat.samples.length}`);
                        if (stat.mean !== null) {
                            const chartDiv = document.createElement('div');
                            chartDiv.className = 'chart-container';
                            chartDiv.style.flex = '1';
                            chartDiv.style.minWidth = '300px';
                            chartDiv.style.height = '350px';
                            chartDiv.style.backgroundColor = 'white';
                            chartDiv.style.border = '1px solid #e0e0e0';
                            chartDiv.style.borderRadius = '5px';
                            chartDiv.style.padding = '10px';
                            
                            const chartTitle = document.createElement('h5');
                            const analysisType = stat.samples.filter(s => s.finalConc !== null && s.finalConc !== undefined && isFinite(s.finalConc)).length > 1 ? 'Individual Analysis' : 'Single Value';
                            chartTitle.textContent = `${stat.sampleName} - ${analysisType}`;
                            chartTitle.style.textAlign = 'center';
                            chartTitle.style.marginBottom = '10px';
                            chartTitle.style.color = '#333';
                            chartDiv.appendChild(chartTitle);
                            
                            const canvas = document.createElement('canvas');
                            chartDiv.appendChild(canvas);
                            chartsRow.appendChild(chartDiv);
                            
                            const color = getControlColor(stat.sampleName);
                            const validConcs = stat.samples
                                .map(s => s.finalConc)
                                .filter(c => c !== null && c !== undefined && isFinite(c));
                            
                            
                            if (validConcs.length > 0) {
                                const datasets = [];
                                
                                // Create scatter points for individual measurements - vertically aligned with slight jitter
                                const scatterData = validConcs.map((conc, idx) => ({
                                    x: 1 + (Math.random() - 0.5) * 0.1, // Slight horizontal jitter to prevent complete overlap
                                    y: conc
                                }));
                                
                                console.log(`${stat.sampleName} scatter data for chart:`, scatterData);
                                console.log(`${stat.sampleName} Y-axis range will be:`, Math.min(...validConcs), 'to', Math.max(...validConcs));
                                
                                datasets.push({
                                    label: `${stat.sampleName} Values`,
                                    data: scatterData,
                                    backgroundColor: color + '80',
                                    borderColor: color,
                                    borderWidth: 2,
                                    pointRadius: 8,
                                    pointHoverRadius: 10,
                                    showLine: false,
                                    type: 'scatter'
                                });
                                
                                // Add mean line (for both single and multiple points)
                                datasets.push({
                                    label: validConcs.length > 1 ? 'Mean' : 'Value',
                                    data: [
                                        {x: 0.3, y: stat.mean},
                                        {x: 1.7, y: stat.mean}
                                    ],
                                    backgroundColor: color,
                                    borderColor: color,
                                    borderWidth: 3,
                                    pointRadius: 0,
                                    showLine: true,
                                    tension: 0,
                                    type: 'line'
                                });
                                
                                // Add 3SD error bands if available (only for multiple points)
                                if (validConcs.length > 1 && stat.sd !== null && stat.sd > 0) {
                                        const threeSd = 3 * stat.sd;
                                        
                                        // Upper 3SD line
                                        datasets.push({
                                            label: '+3SD',
                                            data: [
                                                {x: 0.3, y: stat.mean + threeSd},
                                                {x: 1.7, y: stat.mean + threeSd}
                                            ],
                                            backgroundColor: 'transparent',
                                            borderColor: '#dc3545', // Red color for limits
                                            borderWidth: 2,
                                            borderDash: [8, 4],
                                            pointRadius: 0,
                                            showLine: true,
                                            tension: 0,
                                            type: 'line'
                                        });
                                        
                                        // Lower 3SD line
                                        datasets.push({
                                            label: '-3SD',
                                            data: [
                                                {x: 0.3, y: stat.mean - threeSd},
                                                {x: 1.7, y: stat.mean - threeSd}
                                            ],
                                            backgroundColor: 'transparent',
                                            borderColor: '#dc3545', // Red color for limits
                                            borderWidth: 2,
                                            borderDash: [8, 4],
                                            pointRadius: 0,
                                            showLine: true,
                                            tension: 0,
                                            type: 'line'
                                        });
                                    }
                                
                                // Calculate appropriate Y-axis range including 3SD bounds
                                const minVal = Math.min(...validConcs);
                                const maxVal = Math.max(...validConcs);
                                
                                // Include 3SD bounds in the range calculation
                                let rangeMin = minVal;
                                let rangeMax = maxVal;
                                
                                if (validConcs.length > 1 && stat.sd !== null && stat.sd > 0) {
                                    const threeSd = 3 * stat.sd;
                                    rangeMin = Math.min(rangeMin, stat.mean - threeSd);
                                    rangeMax = Math.max(rangeMax, stat.mean + threeSd);
                                }
                                
                                const range = rangeMax - rangeMin;
                                let padding = range * 0.1; // 10% padding (reduced since we're already including 3SD)
                                
                                // For single values, ensure minimum range for visibility
                                if (range === 0) {
                                    padding = Math.max(rangeMin * 0.2, 1); // 20% of value or minimum 1 unit
                                }
                                
                                const yMin = Math.max(0.01, rangeMin - padding);
                                const yMax = rangeMax + padding;
                                
                                console.log(`${stat.sampleName} Y-axis: ${yMin} to ${yMax} (range: ${range}, padding: ${padding})`);
                                
                                const iqcChart = new Chart(canvas.getContext('2d'), {
                                    type: 'scatter',
                                    data: {
                                        datasets: datasets
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        interaction: {
                                            mode: 'point'
                                        },
                                        scales: {
                                            y: {
                                                type: 'linear', // Use linear scale for individual controls
                                                title: {
                                                    display: true,
                                                    text: 'Concentration (pg/ml)'
                                                },
                                                min: yMin,
                                                max: yMax,
                                                ticks: {
                                                    callback: function(value) {
                                                        return formatNumber(value);
                                                    }
                                                }
                                            },
                                            x: {
                                                type: 'linear',
                                                title: {
                                                    display: true,
                                                    text: 'Control Sample'
                                                },
                                                min: 0,
                                                max: 2,
                                                ticks: {
                                                    stepSize: 1,
                                                    callback: function(value) {
                                                        return value === 1 ? stat.sampleName : '';
                                                    }
                                                }
                                            }
                                        },
                                        plugins: {
                                            legend: {
                                                display: true,
                                                position: 'top'
                                            },
                                            title: {
                                                display: false // Already have title above chart
                                            },
                                            tooltip: {
                                                callbacks: {
                                                    title: function(context) {
                                                        return `${stat.sampleName} - Individual Value`;
                                                    },
                                                    label: function(context) {
                                                        return `Concentration: ${formatNumber(context.parsed.y)} pg/ml`;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                });
                                
                                // Add to charts array for export
                                allCharts.push({
                                    chart: iqcChart,
                                    canvas: canvas,
                                    analyte: analyte,
                                    filename: `${analyte}_${stat.sampleName}_IQC.png`,
                                    type: 'iqc_individual'
                                });
                                console.log(`Created IQC chart for ${stat.sampleName} and added to allCharts. Total charts: ${allCharts.length}`);
                            }
                        }
                    });
                    
                    // Add the horizontal charts row to the analyte section
                    analyteSection.appendChild(chartsRow);
                    console.log(`Added IQC charts row to ${analyte} section. Row contains ${chartsRow.children.length} chart divs`);
                }
                
                tablesContainer.appendChild(analyteSection);
            });
        }

        function generateSummary() {
            const container = document.getElementById('summaryContainer');
            
            let summaryHTML = '<h3>Analysis Summary</h3>';
            summaryHTML += `<p><strong>Analytes Processed:</strong> ${Object.keys(analysisResults).length}</p>`;
            summaryHTML += `<p><strong>Total Samples in Processed Data:</strong> ${processedData.data.length}</p>`;
            summaryHTML += `<p><strong>Plate Format:</strong> ${document.getElementById('plateFormat').value}</p>`;
            summaryHTML += `<p><strong>Dilution Factor:</strong> ${document.getElementById('dilutionFactor').value}</p>`;
            summaryHTML += `<p><strong>Hook Effect Detection:</strong> ${document.getElementById('detectHook').checked ? 'Enabled' : 'Disabled'}</p>`;
            summaryHTML += `<p><strong>Low Standard Filtering:</strong> ${document.getElementById('filterLowStd').checked ? 'Enabled' : 'Disabled'}</p>`;
            
            summaryHTML += '<h4>Analyte Details:</h4>';
            for (const [analyte, results] of Object.entries(analysisResults)) {
                summaryHTML += `<div style="margin: 1rem 0; padding: 1rem; background: #f8f9fa; border-radius: 5px;">`;
                summaryHTML += `<strong>${analyte}:</strong><br>`;
                summaryHTML += `- Standards used in fit: ${results.standards.length} / ${results.allStandards.length}<br>`;
                summaryHTML += `- Background mean: ${formatNumber(results.backgroundMean)}<br>`;
                summaryHTML += `- Hook effect detected: ${results.hookDetected ? 'Yes' : 'No'}<br>`;
                if (results.hookDetected && results.hookConcentration) {
                    summaryHTML += `- Hook concentration (approx.): ${formatNumber(results.hookConcentration)}<br>`;
                }
                summaryHTML += `- Low standards filtered out: ${results.lowStandardsFiltered ? 'Yes' : 'No'}<br>`;
                if (results.lowStandardsFiltered && results.lod) {
                    summaryHTML += `- Filtering threshold used: ${formatNumber(results.lod)} MFI<br>`;
                }
                const validEfficiencies = results.efficiencyData.filter(e => isFinite(e.efficiency));
                if (validEfficiencies.length > 0) {
                    const avgEfficiency = validEfficiencies.reduce((sum, e) => sum + e.efficiency, 0) / validEfficiencies.length;
                    summaryHTML += `- Average efficiency (of standards in fit): ${avgEfficiency.toFixed(4)}%`;
                } else {
                    summaryHTML += `- Average efficiency: N/A (no valid efficiencies calculated)`;
                }
                summaryHTML += `</div>`;
            }
            
            container.innerHTML = summaryHTML;
        }

        async function generateDownloadableFiles() {
            const outputFolder = document.getElementById('outputFolder').value;
            const downloadList = document.getElementById('downloadList');
            // downloadList.innerHTML = ''; // Keep preprocessing files if already added

            // Add charts to export before generating other files
            await addChartsToExport();

            // Add analysis result files, ensuring not to duplicate preprocessing files if names collide
            // Let's ensure preprocessing files are added first if they haven't been.
            // This is handled by showPreprocessingDownloads now.

            let analysisFilesHeaderAdded = downloadList.querySelector('.analysis-files-header');
            if (!analysisFilesHeaderAdded && Object.keys(analysisResults).length > 0) {
                 const separator = document.createElement('div');
                separator.style.borderTop = '2px solid #ddd';
                separator.style.margin = '1rem 0';
                separator.innerHTML = '<strong class="analysis-files-header">Analysis Results:</strong>';
                downloadList.appendChild(separator);
            }
            
            // Generate CSV files for each analyte
            for (const [analyte, results] of Object.entries(analysisResults)) {
                // Individual analyte files removed to reduce output clutter
                // All results and efficiency data are available in consolidated files
            }
            
            // Essential consolidated files only
            if (Object.keys(analysisResults).length > 0) {
                // Efficiency data - consolidated efficiency for all analytes
                const efficiencyLongCSV = generateEfficiencyLongCSV();
                const efficiencyLongKey = `${outputFolder}_efficiency_data.csv`;
                generatedFiles[efficiencyLongKey] = efficiencyLongCSV;
                addDownloadItem('Efficiency Data', efficiencyLongCSV, efficiencyLongKey);
                
                // IQC values export - matches Python version
                const iqcCSV = generateIQCExportCSV();
                if (iqcCSV) {
                    const iqcKey = `${outputFolder}_${new Date().toISOString().slice(0,19).replace(/[:.]/g, '-')}_IQC_values.csv`;
                    generatedFiles[iqcKey] = iqcCSV;
                    addDownloadItem('IQC Values Export', iqcCSV, iqcKey);
                }
                
                // Add chart download items
                allCharts.forEach(chartInfo => {
                    if (chartInfo && chartInfo.filename) {
                        const chartKey = `${outputFolder}_${chartInfo.filename}`;
                        if (generatedFiles[chartKey]) {
                            const displayName = chartInfo.type === 'iqc_comparison' ? 
                                'IQC - Concentration Comparison Chart' : 
                                chartInfo.type === 'efficiency' ?
                                `${chartInfo.analyte} - Efficiency Chart` :
                                `${chartInfo.analyte} - Standard Curve Chart`;
                            addDownloadItem(displayName, generatedFiles[chartKey], chartKey);
                        }
                    }
                });
            }
        }

        
        function generateEfficiencyLongCSV() {
            // Generate efficiency data in long format (Analyte, Concentration, Efficiency columns)
            const headers = ['Analyte', 'Concentration', 'Efficiency'];
            let csv = headers.join(',') + '\n';
            
            Object.keys(analysisResults).forEach(analyte => {
                const results = analysisResults[analyte];
                results.efficiencyData.forEach(row => {
                    csv += `${analyte},${formatMfiConc(row.concentration)},${isFinite(row.efficiency) ? row.efficiency.toFixed(4) : ''}\n`;
                });
            });
            
            return csv;
        }
                        
        function generateIQCExportCSV() {
            // Generate IQC (Internal Quality Control) values export for samples matching IQC pattern
            // Returns CSV string if IQC samples found, null otherwise
            
            // Check if any analyte has IQC samples
            const allAnalytes = Object.keys(analysisResults);
            let hasIQCSamples = false;
            const iqcSamples = new Map(); // Map to store unique IQC samples
            
            // Find all IQC samples across all analytes
            allAnalytes.forEach(analyte => {
                const results = analysisResults[analyte];
                console.log(`Checking analyte ${analyte} for IQC samples. Total samples: ${results.data.length}`);
                const analyteIQCSamples = results.data.filter(row => {
                    if (!row.sample) return false;
                    const sampleStr = String(row.sample).toUpperCase();
                    const isIQC = sampleStr.startsWith('IQC') || sampleStr.startsWith('CONTROL');
                    if (isIQC) {
                        console.log(`Found IQC sample: ${row.sample} (${sampleStr})`);
                    }
                    return isIQC;
                });
                
                console.log(`Found ${analyteIQCSamples.length} IQC samples for ${analyte}`);
                if (analyteIQCSamples.length > 0) {
                    hasIQCSamples = true;
                    analyteIQCSamples.forEach(sample => {
                        const key = `${sample.sample}|${sample.location || ''}`;
                        if (!iqcSamples.has(key)) {
                            iqcSamples.set(key, {
                                sample: sample.sample,
                                location: sample.location || ''
                            });
                        }
                    });
                }
            });
            
            if (!hasIQCSamples) {
                console.log('No IQC samples found. Skipping IQC export.');
                return null;
            }
            
            // Prepare headers: Sample, Location, then 4 columns for each analyte
            const headers = ['Sample', 'Location'];
            allAnalytes.forEach(analyte => {
                // Clean analyte name for column headers (replace spaces/hyphens with dots)
                const analyteClean = analyte.replace(/[\s-]/g, '.');
                headers.push(
                    `${analyteClean}_Raw_MFI`,
                    `${analyteClean}_Corrected_MFI`,
                    `${analyteClean}_Concentration`,
                    `${analyteClean}_Final_Concentration`
                );
            });
            
            let csv = headers.join(',') + '\n';
            
            // Generate data rows for each unique IQC sample
            Array.from(iqcSamples.values()).forEach(iqcSample => {
                const row = [
                    `"${String(iqcSample.sample).replace(/"/g, '""')}"`,
                    `"${String(iqcSample.location).replace(/"/g, '""')}"`
                ];
                
                // For each analyte, find matching data and add the 4 columns
                allAnalytes.forEach(analyte => {
                    const results = analysisResults[analyte];
                    const matchingData = results.data.find(dataRow => 
                        dataRow.sample === iqcSample.sample && 
                        (dataRow.location || '') === iqcSample.location
                    );
                    
                    if (matchingData) {
                        // Add the 4 data columns for this analyte
                        row.push(formatMfiConc(matchingData.mfi));
                        row.push(formatMfiConc(matchingData.correctedMfi));
                        row.push(formatMfiConc(matchingData.calculatedConc));
                        row.push(formatMfiConc(matchingData.finalConc));
                    } else {
                        // Add empty values if no matching data found
                        row.push('', '', '', '');
                    }
                });
                
                csv += row.join(',') + '\n';
            });
            
            return csv;
        }

        function addDownloadItem(displayName, content, filename = null) {
            const downloadList = document.getElementById('downloadList');
            const fileToDownload = filename || displayName.replace(/[^a-z0-9_.-]/gi, '_') + '.csv'; // Sanitize filename

            // Avoid adding duplicate download items if function is called multiple times for same file
            const existingItem = Array.from(downloadList.children).find(child => child.dataset.filename === fileToDownload);
            if (existingItem) {
                // Optionally update content if it might change, or just return
                // For simplicity, we'll assume content is final when first added.
                return;
            }

            const item = document.createElement('div');
            item.className = 'download-item';
            item.dataset.filename = fileToDownload; // Store filename for checking duplicates
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = displayName;
            
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'btn';
            downloadBtn.textContent = 'Download';
            downloadBtn.style.padding = '0.5rem 1rem';
            
            downloadBtn.onclick = () => downloadFile(fileToDownload, content);
            
            item.appendChild(nameSpan);
            item.appendChild(downloadBtn);
            downloadList.appendChild(item);
        }

        async function selectOutputDirectory() {
            try {
                if ('showDirectoryPicker' in window) {
                    // Use File System Access API for modern browsers
                    outputDirectoryHandle = await window.showDirectoryPicker();
                    document.getElementById('selectedDirPath').textContent = 
                        `Selected: ${outputDirectoryHandle.name}`;
                    updateStatus('Output directory selected successfully', 'success');
                } else {
                    // Fallback for browsers without File System Access API
                    updateStatus('Directory selection not supported by this browser. Files will download to your default browser download location.', 'info');
                    document.getElementById('selectedDirPath').textContent = 
                        'Directory selection not supported in this browser';
                }
            } catch (error) {
                console.error('Error selecting directory:', error);
                 if (error.name === 'AbortError') {
                    updateStatus('Directory selection cancelled.', 'info');
                } else {
                    updateStatus('Directory selection failed. Files will download to default location.', 'info');
                }
            }
        }

        async function downloadFile(filename, content) {
            try {
                if (outputDirectoryHandle && typeof outputDirectoryHandle.getFileHandle === 'function') {
                    // Save to selected directory using File System Access API
                    const fileHandle = await outputDirectoryHandle.getFileHandle(filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    updateStatus(`Saved ${filename} to selected directory: ${outputDirectoryHandle.name}`, 'success');
                } else {
                    // Fallback to regular download
                    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                    saveAs(blob, filename);
                }
            } catch (error) {
                console.error(`Error saving file ${filename}:`, error);
                updateStatus(`Error saving ${filename}. Falling back to standard download. Error: ${error.message}`, 'error');
                // Fallback to regular download if directory save fails
                try {
                    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                    saveAs(blob, filename);
                } catch (fallbackError) {
                     console.error(`Fallback download also failed for ${filename}:`, fallbackError);
                     updateStatus(`Could not save ${filename} via directory or fallback. Error: ${fallbackError.message}`, 'error');
                }
            }
        }

        async function downloadAllFiles() {
            const outputFolderForZip = document.getElementById('outputFolder').value || "LuminexResults";
            
            try {
                if (outputDirectoryHandle && typeof outputDirectoryHandle.getDirectoryHandle === 'function') {
                    // Create subdirectory and save all files
                    updateStatus('Saving all files to selected directory...', 'info');
                    
                    let targetDir = outputDirectoryHandle;
                    try {
                        // Attempt to create/get a subdirectory named after the outputFolder value
                        targetDir = await outputDirectoryHandle.getDirectoryHandle(outputFolderForZip, { create: true });
                         updateStatus(`Saving files into subfolder: ${outputFolderForZip} within ${outputDirectoryHandle.name}`, 'info');
                    } catch (error) {
                        console.warn(`Could not create/access subdirectory '${outputFolderForZip}', saving to main selected directory '${outputDirectoryHandle.name}'. Error: ${error}`);
                        updateStatus(`Saving files into main selected directory: ${outputDirectoryHandle.name}`, 'info');
                        targetDir = outputDirectoryHandle; // Fallback to the root selected directory
                    }
                    
                    let filesSavedCount = 0;
                    for (const [filename, content] of Object.entries(generatedFiles)) {
                        try {
                            const fileHandle = await targetDir.getFileHandle(filename, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(content);
                            await writable.close();
                            filesSavedCount++;
                        } catch (indivFileError) {
                            console.error(`Error saving individual file ${filename} to directory:`, indivFileError);
                            updateStatus(`Error saving ${filename} to directory. It will be skipped.`, 'error');
                        }
                    }
                     updateStatus(`${filesSavedCount} files saved to directory: ${targetDir.name}`, 'success');
                } else {
                    // Fallback to ZIP download
                    updateStatus('Preparing ZIP file for download...', 'info');
                    const zip = new JSZip();
                    
                    // Add all generated files to ZIP, potentially in a folder
                    const zipFolder = zip.folder(outputFolderForZip);

                    console.log('Adding files to ZIP:', Object.keys(generatedFiles));
                    for (const [filename, content] of Object.entries(generatedFiles)) {
                        console.log(`Adding to ZIP: ${filename}`, {
                            type: typeof content,
                            isUint8Array: content instanceof Uint8Array,
                            size: content.length || content.size,
                            isPNG: filename.endsWith('.png')
                        });
                        zipFolder.file(filename, content);
                    }
                    
                    // Generate and download ZIP
                    const blob = await zip.generateAsync({ type: 'blob' });
                    saveAs(blob, `${outputFolderForZip}.zip`);
                    updateStatus('ZIP file downloaded successfully!', 'success');
                }
            } catch (error) {
                console.error('Error downloading/saving all files:', error);
                updateStatus('Error saving all files: ' + error.message, 'error');
            }
        }

        function showPreprocessingDownloads() {
            const downloadSection = document.getElementById('downloadSection');
            const downloadList = document.getElementById('downloadList');
            
            // Clear only items not marked as preprocessing results to avoid duplicates
            // Or simply ensure addDownloadItem handles duplicates
            // downloadList.innerHTML = ''; // Re-evaluating this clear

            const outputFolder = document.getElementById('outputFolder').value;
            const cleanDataKey = `${outputFolder}_clean_data.csv`;
            const leftoverDataKey = `${outputFolder}_leftover_data.csv`;
            
            // Add preprocessing files if they exist and aren't already listed
            if (generatedFiles[cleanDataKey]) {
                addDownloadItem('Clean Data (for downstream analysis)', generatedFiles[cleanDataKey], cleanDataKey);
            }
            if (generatedFiles[leftoverDataKey]) {
                addDownloadItem('Leftover Data (excluded from analysis)', generatedFiles[leftoverDataKey], leftoverDataKey);
            }
            
            // Add note about files if it's not there yet
            if (!downloadList.querySelector('.preprocessing-note')) {
                const noteDiv = document.createElement('div');
                noteDiv.className = 'preprocessing-note'; // Add a class to check for existence
                noteDiv.style.marginTop = '1rem';
                noteDiv.style.padding = '0.75rem';
                noteDiv.style.backgroundColor = '#e3f2fd';
                noteDiv.style.borderRadius = '5px';
                noteDiv.style.fontSize = '0.9rem';
                noteDiv.innerHTML = `
                    <strong>Note:</strong> The clean data file contains only the main analysis data and can be used for downstream processing. 
                    The leftover data file contains metadata and other information that was excluded from the analysis.
                `;
                // Prepend note so it appears above other files if downloadList was already populated
                if (downloadList.firstChild) {
                    downloadList.insertBefore(noteDiv, downloadList.firstChild);
                } else {
                    downloadList.appendChild(noteDiv);
                }
            }
            
            // Show the download section
            downloadSection.style.display = 'block';
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');
        }
    </script>
</body>
</html>